(* ::Package:: *)

(* ::Title:: *)
(*Simulation scan: Run and Tumble Motion on a Sphere*)


(* ::Chapter::Closed:: *)
(*Initialization*)


Get[FileNameJoin[{NotebookDirectory[],"functions.wl"}]];


(* ::Chapter:: *)
(*Simulations: run and tumble *)


(* ::Section:: *)
(*3d position with 3d orientation vector*)


(* ::Subsection::Closed:: *)
(*constant simulation parameters*)


{diffRotDim,swimMultiplier,rEcoliShortDim}={3.5,1.0,0.5*^-6};
{u0Dim,rDropletDim}={20.0*^-6,3.5*^-6};
{diffS,timeFactor,asymmetry}={115,0.186,16.0};
{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};  (** s, , **)
stepSize=1;  (** step size for shrinking simulated to analyzed data **)
fudgeFactor=1.0;


(* ::Subsection::Closed:: *)
(*physics*)


(* ::Subsubsection:: *)
(*nice table of physical parameters*)


(* ::Input:: *)
(*calcPhysicalParameters[u0Dim,rDropletDim];*)
(*mEcoli=4./3 \[Pi] 2 1 1 (10^-6)^3 1100; (** in kg **)*)
(**)
(*(*period=2\[Pi] dragDim rcomDim^2/Sqrt[(swimFactor dragTransDim u0Dim(rDropletDim+rEcoliDim))^2-(mDim gDim rcomDim)^2];*)*)
(*period=2\[Pi] dragDim/Sqrt[(dragSwimDim u0Dim(rDropletDim+rEcoliDim))^2-(mDim gDim rcomDim)^2];*)
(*frequency=1.0/period;*)
(*meanSpeed=2\[Pi] (rDropletDim+rEcoliDim)/period*)
(**)
(*strings={"bacterium speed \!\(\*SubscriptBox[\(u\), \(0\)]\) (m/s)","\[Eta] (kg/s)","\!\(\*SubscriptBox[\(r\), \(droplet\)]\) (m)","\!\(\*SubscriptBox[\(v\), \(R\)]\)","\!\(\*SubscriptBox[\(r\), \(interface\)]\) (m)","\!\(\*SubscriptBox[\(r\), \(Bacterium\)]\) (m)","\!\(\*SubscriptBox[\(\[Gamma]\), \(trans\)]\) (kg \!\(\*SuperscriptBox[\(m\), \(2\)]\)/s)","\!\(\*SubscriptBox[\(\[Gamma]\), \(rot\)]\) (kg \!\(\*SuperscriptBox[\(m\), \(2\)]\)/s)","\[Gamma] (kg \!\(\*SuperscriptBox[\(m\), \(2\)]\)/s)","\!\(\*SubscriptBox[\(\[Gamma]\), \(active\)]\) (kg \!\(\*SuperscriptBox[\(m\), \(2\)]\)/s)","g (m/\!\(\*SuperscriptBox[\(s\), \(2\)]\))","\!\(\*SubscriptBox[\(D\), \(rot\)]\)","\!\(\*SubscriptBox[\(\[Rho]\), \(1\)]\) (kg/\!\(\*SuperscriptBox[\(m\), \(3\)]\))","\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\) (kg/\!\(\*SuperscriptBox[\(m\), \(3\)]\))","mass m (kg)","\!\(\*SubscriptBox[\(r\), \(com\)]\) (m)","period T (s)","mean speed \[LeftAngleBracket]v\[RightAngleBracket] (m/s)","diffS","asymmetry"};*)
(*values={u0Dim,\[Eta],rDropletDim,volumeRatio,rInterfaceDim,rEcoliDim,dragTransDim,dragRotDim,dragDim,dragSwimDim,gDim,diffR,\[Rho]FDim,\[Rho]HDim,mDim,rcomDim,period,meanSpeed,diffS,asymmetry};*)
(*Grid[{strings,values}\[Transpose],Frame->All]*)


(* ::Input:: *)
(*dragTransDim*)


(* ::Input:: *)
(*dragRotDim *)


(* ::Subsubsection::Closed:: *)
(*attachment probability on cylinder with spherical caps*)


(* ::Text:: *)
(*Does not matter, if we assume, that reorientation happens due to flow and is on a much faster time scale*)


(* ::Input:: *)
(*{rCap,lBody}={0.5,2.0};*)
(*(*rCap=1.0;*)*)
(*Graphics3D[{CapsuleShape[{{0,0,0},{lBody-2rCap,0,0}},rCap]}]*)
(*aBody=2.0\[Pi] rCap (lBody-2rCap);*)
(*aCaps=2 0.5 4\[Pi] rCap^2;*)
(*totalArea=aCaps+aBody;*)
(**)
(*pBody=aBody/totalArea*)
(*pCaps=aCaps/totalArea*)


(* ::Subsubsection::Closed:: *)
(*swim vs. gravity forces 2d*)


(* ::Input:: *)
(*Clear[r,\[Theta]];*)
(*pCircle[r,\[Theta]]*)
(*Solve[pCircle[r,\[Theta]] . (a{Cos[\[Theta]],-Sin[\[Theta]]}+b{0,-1})=={0,0},\[Theta]]*)


(* ::Input:: *)
(*rEcoliDim=1.0*^-6;*)
(*u0Dim= 20.0*^-6;                            (** constant speed: 20 micron/s **)*)
(*gDim=9.81;              (** gravitational constant in m/s^2 **)*)
(*{{\[Rho]FDim,\[Rho]HDim},{rDropletDim,rInterfaceDim,volumeRatio}}={{1.01*^3,1.44*^3},{5.0*^-6,100.0*^-6,1.0}};*)
(*(*b[rd_]:=m gDim rcm/(rd+0.5rEcoliDim);*)*)
(*b[rd_]:=1/(rd+0.5);*)
(*a[u0_]:=(*\[Mu]*)1 u0;*)
(*ContourPlot[ArcTan[Sqrt[-a[u0]^2+b[rd]^2]/b[rd],-(a[u0]/b[rd])]+\[Pi],{rd,0,10},{u0,0,1}]*)


(* ::Input:: *)
(*ContourPlot[ArcTan[-(Sqrt[-a^2+b^2]/b),-(a/b)],{a,0,1},{b,0,1}]*)


(* ::Subsubsection::Closed:: *)
(*swim vs. gravity forces 3d*)


(* ::Text:: *)
(*assume \[Phi]=0*)


(* ::Input:: *)
(*pSphere[r,\[Theta],0]*)
(*Solve[pSphere[r,\[Theta],0] . (a{Cos[\[Theta]],0,-Sin[\[Theta]]}+b{0,0,-1})=={0,0,0},\[Theta]]*)


(* ::Subsubsection::Closed:: *)
(*simulate pole-pole trajectory*)


(* ::Input:: *)
(*DSolve[D[x[t],t]==u0-g Sin[x[t]],x,t]*)


(* ::Input:: *)
(*{g,u0}={1,1. 1.01};*)
(*sol=NDSolveValue[{D[x[t],t]==u0-g Sin[x[t]],x[0]==-\[Pi]},x,{t,0,100}];*)
(*Plot[sol[t],{t,0,100},PlotRange->All,Prolog->{Gray,Line[{{0,0.5\[Pi]},{100,0.5\[Pi]}}]}]*)


(* ::Subsubsection::Closed:: *)
(*compute SNIPER period for polar dynamics*)


(* ::Input:: *)
(*Integrate[1/(a-b Sin[x]),{x,0,2\[Pi]},Assumptions->a>b>0]*)


(* ::Input:: *)
(*Plot[1/((2 \[Pi])/Sqrt[a^2-b^2])/.a->0.5,{b,0,1}];*)
(*Plot[1/((2 \[Pi])/Sqrt[a^2-b^2])/.b->0.5,{a,0,1}]*)


(* ::Input:: *)
(*Clear[m,g]*)
(*Integrate[1/(a-b Sin[x]),{x,0,2\[Pi]},Assumptions->a>b>0]/.{a->Subscript[\[Mu], a]/Subscript[\[Mu], p] Subscript[u, 0]/(Subscript[r, droplet]+Subscript[r, Ecoli]),b->m g Subscript[r, COM]/(Subscript[r, droplet]+Subscript[r, Ecoli])^2/Subscript[\[Mu], p]}//Simplify*)


(* ::Input:: *)
(*dragSwimDim/dragDim u0Dim/(rDropletDim+rEcoliDim)*)
(*mDim gDim rcomDim/(rDropletDim+rEcoliDim)^2/dragDim*)


(* ::Input:: *)
(*freq=1/Integrate[1/(a-b Sin[x]),{x,0,2\[Pi]},Assumptions->a>b>0]/.{*)
(*a->dragSwimDim(*/dragDim*) u0Dim/(rDropletDim+rEcoliDim),*)
(*b->mDim gDim rcomDim/(rDropletDim+rEcoliDim)^2(*/dragDim*)*)
(*}*)


(* ::Input:: *)
(*gDim^2 mDim^2 rcomDim^2/((rDropletDim+rEcoliDim)^4 dragDim^2)*)
(*(rDropletDim+rEcoliDim)^2 u0^2 dragSwimDim^2/((rDropletDim+rEcoliDim)^4 dragDim^2)*)


(* ::Input:: *)
(*Plot[Sqrt[((-gDim^2 mDim^2 rcomDim^2+(rDropletDim+rEcoliDim)^2 u0^2 dragSwimDim^2)/((rDropletDim+rEcoliDim)^4 dragDim^2))]/(2\[Pi]),{u0,0,20.0*^-6},Frame->True,FrameLabel->{"speed","frequency f"},ScalingFunctions->{"Reverse",Identity},PlotStyle->Red*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*compute speed of tilted great circle parametrized trajectories*)


(* ::Input:: *)
(*circlePts=Table[{Cos[t],0.0,Sin[t]},{t,0,2\[Pi],0.01 2\[Pi]}];*)
(*Manipulate[*)
(*pts=RotationMatrix[tiltAngle,{1,0,0}] . #&/@circlePts;*)
(*ListPointPlot3D[pts,BoxRatios->1,PlotRange->1.2{{-1,1},{-1,1},{-1,1}}]*)
(*,{tiltAngle,0.0,2\[Pi],2\[Pi] 0.001},TrackedSymbols:>tiltAngle]*)


(* ::Input:: *)
(*dragTransDim=6\[Pi] \[Eta]  rEcoliDim;*)


(* ::Input:: *)
(*dragTransDim=6\[Pi] \[Eta]  rEcoliDim;    (** in kg / s **)*)
(*dragRotDim=8\[Pi] \[Eta]  rDropletDim^3/(rDropletDim+rEcoliDim)^2;    (** in kg / s **)*)
(*dragDim=dragTransDim+dragRotDim;*)
(**)
(*circlePts=Table[{Cos[t],0.0,Sin[t]},{t,Subdivide[0.0,2\[Pi],100][[;;-2]]}];*)
(*Manipulate[*)
(*positions=RotationMatrix[tiltAngle,{1,0,0}] . #&/@circlePts;*)
(*polarizations=Table[Normalize[positions[[Mod[i+1,Length[positions],1]]]-positions[[Mod[i-1,Length[positions],1]]]],{i,1,Length[positions]}];*)
(*velocities=MapThread[1.0/dragDim sphereSurfaceProjector[#1] . (fSwim[#2]-fGrav)&,{positions,polarizations}];*)
(*(*meanSpeed=Mean[Norm/@velocities];*)*)
(*meanSpeed=HarmonicMean[Norm/@velocities];*)
(*meanPeriod=2\[Pi] (rDropletDim+rEcoliDim)/HarmonicMean[Norm/@velocities];*)
(*ListPlot[Norm/@velocities,Frame->True,PlotLabel->{meanSpeed,meanPeriod},PlotRange->{0,9}1*^-6]*)
(*,{tiltAngle,0.0,\[Pi]/2,2\[Pi] 0.001},TrackedSymbols:>tiltAngle]*)


(* ::Input:: *)
(*meanFreq=meanSpeed/(2\[Pi] (rDropletDim+rEcoliDim))*)


(* ::Input:: *)
(*meanPeriod=2\[Pi] (rDropletDim+rEcoliDim)/(5*^-6)*)


(* ::Input:: *)
(*MapThread[#1 . #2&,{positions,polarizations}]//MinMax*)
(*MapThread[#1 . #2&,{positions,velocities}]//MinMax*)


(* ::Subsection::Closed:: *)
(*tests*)


(* ::Subsubsection::Closed:: *)
(*frequency identification*)


(* ::Input:: *)
(*timeseriesDuration=100;*)
(*{foundFrequency,freqs,powerSpectralDensity}=ftFrequencyIdentification[thetaData,timeseriesDuration];*)
(*ListPlot[{freqs,powerSpectralDensity}\[Transpose][[2;;100]],PlotRange->All,Joined->True,Frame->True,FrameLabel->{"angular frequency \[Omega] (Hz)","power spectral density \!\(\*SubscriptBox[\(S\), \(\[Theta]\)]\)(\[Omega])"},FrameStyle->Directive[Black,24],ImageSize->500]*)
(**)
(*timeseriesDuration=100;*)
(*{foundFrequency,freqs,powerSpectralDensity}=ftFrequencyIdentification[sData,timeseriesDuration];*)
(*ListPlot[{freqs,powerSpectralDensity}\[Transpose][[2;;100]],PlotRange->All,Joined->True,Frame->True,FrameLabel->{"angular frequency \[Omega] (Hz)","power spectral density \!\(\*SubscriptBox[\(S\), \(s\)]\)(\[Omega])"},FrameStyle->Directive[Black,24],ImageSize->500]*)


(* ::Subsubsection::Closed:: *)
(*mathematica simulation for RT on sphere*)


(* ::Text:: *)
(*does not work*)


(* ::Input:: *)
(*{diffR,diffS}={3.5 10,120.0};*)
(*{t1,tfinal,dt,nSaveSteps}={0,10,0.0001,100};*)
(*{{x0,y0,z0},{p\[Theta]0,p\[Phi]0},s0,{\[Sigma]1,\[Sigma]2,\[Sigma]3,\[Sigma]s}}={{1,0,0},{0.5\[Pi],1.0},0.01(*1.0*),1{1,1,1,1}};*)
(**)
(*Clear[t,x,y,z,p\[Theta],p\[Phi],s];*)
(*process=ItoProcess[{*)
(*\[DifferentialD]x[t]==(Abs[1-s[t]]u0 Cos[p\[Phi][t]] Sin[p\[Theta][t]])\[DifferentialD]t,*)
(*\[DifferentialD]y[t]==(Abs[1-s[t]]u0  Sin[p\[Phi][t]]Sin[p\[Theta][t]])\[DifferentialD]t,*)
(*\[DifferentialD]z[t]==(Abs[1-s[t]]u0 Cos[p\[Theta][t]])\[DifferentialD]t,*)
(*\[DifferentialD]p\[Theta][t]==Abs[s[t]]diffR 0.5Cot[p\[Theta][t]]\[DifferentialD]t+Sqrt[Abs[s[t]]diffR](Sin[p\[Phi][t]]\[DifferentialD]w1[t]-Cos[p\[Phi][t]]\[DifferentialD]w2[t]),*)
(*\[DifferentialD]p\[Phi][t]==Sqrt[Abs[s[t]]diffR](Cot[p\[Theta][t]](Cos[p\[Phi][t]]\[DifferentialD]w1[t]+Sin[p\[Phi][t]]\[DifferentialD]w2[t])-\[DifferentialD]w3[t]),*)
(*\[DifferentialD]s[t]==-\!\( *)
(*\*SubscriptBox[\(\[PartialD]\), \(s\)]\(u[s[t]]\)\)\[DifferentialD]t+Sqrt[diffS] \[DifferentialD]ws[t]*)
(*},*)
(*{x[t],y[t],z[t],p\[Theta][t],p\[Phi][t],s[t]},*)
(*{*)
(*{x,y,z,p\[Theta],p\[Phi],s},*)
(*{x0,y0,z0,p\[Theta]0,p\[Phi]0,s0}*)
(*},t,*)
(*{*)
(*w1\[Distributed]WienerProcess[0,\[Sigma]1],*)
(*w2\[Distributed]WienerProcess[0,\[Sigma]2],*)
(*w3\[Distributed]WienerProcess[0,\[Sigma]3],*)
(*ws\[Distributed]WienerProcess[0,\[Sigma]s]*)
(*}*)
(*];*)
(**)
(*trajectory=RandomFunction[process,{t1,tfinal,dt}]["ValueList"][[1,;;;;nSaveSteps]];*)
(*trajectory//Dimensions*)


(* ::Subsubsection::Closed:: *)
(*check mean PSD*)


(* ::Input:: *)
(*{sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,sWidth,\[Theta]Width,iWidth,meanThetaFit}=calcFits[fMax,freqs,mPSDs,mPSD\[Theta],mPSDi];*)


(* ::Input:: *)
(*ops={AspectRatio->1,ImageSize->400,Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],ColorFunctionScaling->False,PlotRangePadding->{0,Scaled[0.05]},ImagePadding->{{85,15},{60,10}}};*)
(*fwhmPoints={0.08,0.5};*)
(*pPSDi=Show[*)
(*	ListLinePlot[{{freqs,#/Max[#]&@mPSDi}\[Transpose](*,{freqs,mPSDi-stdPSDi}\[Transpose],{freqs,mPSDi+stdPSDi}\[Transpose]*)},Evaluate[ops],FrameLabel->{"Frequency f (Hz)","PSD(i)"},PlotRange->{{0,fMax},All},PlotStyle->(Directive[ColorData[97,1],AbsoluteThickness[#]]&/@{4,1,1}),Filling->{3->{2}},PlotLegends->Placed[{"data"},{Right,Top}]]*)
(*	(*,Plot[iFit[x],{x,0,fMax},PlotStyle\[Rule]Directive[Red,Opacity[0.6]],PlotRange\[Rule]All]*)*)
(*	,Plot[(*Max[mPSDi]*)iFitTheory[x],{x,0,fMax},PlotStyle->Directive[Green,Opacity[0.6]],PlotRange->All,PlotLegends->Placed[{"Lorentz fit"},{Right,Top}]]*)
(*,Epilog->{Red,AbsolutePointSize[10],Point[#],AbsoluteThickness[2],Dashed,HalfLine[{#,{0,0.5}}],HalfLine[{#,{#[[1]],0}}]}&@fwhmPoints*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*check PSD fits*)


(* ::Input:: *)
(*{u0Dim,diffRot,rDropletDim,swimMultiplier}={20.0*^-6,3.5,3.5*^-6,1.9};*)
(*{diffS,timeFactor,asymmetry}={115,0.186,16.0}; *)
(*{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};*)
(*u0Dim=20(*10*) 1.0*^-6*)
(**)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(*runSimulation[{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed}];      (** run simulation **)*)
(*{nStepsFine,dtFine,timesFine,fineTrajectories}=readSimulationOutput[tfinalSim];                                                                                                    (** read simulation output **)*)
(*{nSteps,dt,times,trajectories}={nStepsFine,dtFine,timesFine[[;;;;1]],fineTrajectories[[All,;;;;1]]};*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,sData,thetaData,phiData,iData,phasesS,phases\[Theta],phasesI}=calcMeanPowerSpectra[trajectories,dt];*)


(* ::Input:: *)
(*ListLinePlot[mPSDs[[2;;100]],PlotRange->All]*)
(*ListPlot[mPSD\[Theta][[2;;100]],PlotRange->All,Joined->True]*)
(*ListPlot[mPSDi[[2;;100]],PlotRange->All,Joined->True]*)


(* ::Input:: *)
(*phases\[Theta]//Dimensions*)
(*ListPlot[Mean/@phases\[Theta],PlotRange->{-\[Pi],\[Pi]},Frame->True]*)
(*ListPlot[Mean@phases\[Theta],PlotRange->{-\[Pi],\[Pi]},Frame->True]*)
(*ListPlot[phases\[Theta][[All,;;100]],Frame->True]*)
(*MatrixPlot[phases\[Theta][[All,;;100]]]*)


(* ::Input:: *)
(*Manipulate[*)
(*zData=trajectories[[i,All,3]];*)
(*thetaData=\[Pi]-ArcCos[#[[3]]]&/@trajectories[[i,All,{1,2,3}]];*)
(*iData=Cos[#]^2 &/@ thetaData;*)
(*{freqs,psd\[Theta],phase\[Theta]}=calculateTemporalFreqSpectrum[dt,thetaData];*)
(*{freqs,psdi,phasei}=calculateTemporalFreqSpectrum[dt,iData];*)
(*(*p0=ListPlot[zData,PlotRange\[Rule]{-1,1},Frame\[Rule]True,ImageSize\[Rule]300,PlotLabel\[Rule]"z"];*)*)
(*p0=ListPlot[thetaData,PlotRange->{0,\[Pi]},Frame->True,ImageSize->300,PlotLabel->"\[Theta]"];*)
(*p1=ListPlot[iData,PlotRange->{0,All},Frame->True,ImageSize->300,PlotLabel->"I"];*)
(*p2=ListLinePlot[psd\[Theta][[2;;100]],PlotRange->{1.0*^-8,1000},Frame->True,ImageSize->300,PlotLabel->"abs(FT(\[Theta])\!\(\*SuperscriptBox[\()\), \(2\)]\)"];*)
(*p3=ListPlot[phase\[Theta][[2;;100]],PlotRange->{-\[Pi],\[Pi]},Frame->True,ImageSize->300,PlotLabel->"phase(FT(\[Theta]))"];*)
(*p4=ListLinePlot[Rescale[psdi[[2;;100]]],PlotRange->{0,1}(*{1.0*^-8,1000}*),Frame->True,ImageSize->300,PlotLabel->"abs(FT(i)\!\(\*SuperscriptBox[\()\), \(2\)]\)"];*)
(*p5=ListPlot[phasei[[2;;100]],PlotRange->{-\[Pi],\[Pi]},Frame->True,ImageSize->300,PlotLabel->"phase(FT(i))"];*)
(*Grid[{{p0,p1},{p2,p4},{p3,p5}}]*)
(*,{i,1,200,1}]*)


(* ::Input:: *)
(*pthout=FileNameJoin[{NotebookDirectory[],"output"}];*)
(*If[!DirectoryQ[#],CreateDirectory[#]]&@pthout;*)
(**)
(*{u0Dim,diffRot,rDropletDim,swimMultiplier}={20.0*^-6,3.5,3.5*^-6,1.9};*)
(*{diffS,timeFactor,asymmetry}={115,0.186,16.0}; *)
(*{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};*)
(**)
(*u0Dims=Range[1,20,1] 1.0*^-6;*)
(*u0Dims={20 1.0*^-6};*)
(*{simData,spectraTheta,spectraI}=Table[*)
(*Print[{rDropletDim,u0Dim}];*)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(**)
(*runSimulation[{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed}];      (** run simulation **)*)
(*{nStepsFine,dtFine,timesFine,fineTrajectories}=readSimulationOutput[tfinalSim];                                                                                                    (** read simulation output **)*)
(*(*{nSteps,dt,times,trajectories}={nStepsFine/10,10dtFine,timesFine\[LeftDoubleBracket];;;;10\[RightDoubleBracket],fineTrajectories\[LeftDoubleBracket]All,;;;;10\[RightDoubleBracket]};*)*)
(*{nSteps,dt,times,trajectories}={nStepsFine,dtFine,timesFine[[;;;;1]],fineTrajectories[[All,;;;;1]]};*)
(**)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];                                                                (** calculate transition statistics for theory **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,sData,thetaData,phiData,iData,phaseS,phase\[Theta],phaseI}=calcMeanPowerSpectra[trajectories,dt];                                                           (** calculate mean power spectral densities, fit and width **)*)
(**)
(*velocityForceObservables=calcTangentVelocitiesForces[trajectories,dt,swimFactor,gravFactor,rDropletDim];*)
(**)
(*Clear[x,x0,amp,bb];*)
(*indexStart=2;*)
(*{sFit,\[Theta]Fit,iFit}=NonlinearModelFit[{freqs,#}\[Transpose][[indexStart;;]],amp/( 1+(x-x0)^2/bb^2),{{amp,1},{bb,0.01},{x0,0.01}},x]&/@{mPSDs,mPSD\[Theta],mPSDi};*)
(*{sWidth,\[Theta]Width,iWidth}=Abs[#["BestFitParameters"][[2,2]]]&/@{sFit,\[Theta]Fit,iFit};*)
(**)
(*(** plots **)*)
(*rEcoliShort=0.5*^-6/rDropletDim;  (**  rescaled radius of E. coli **)*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[times,fineTrajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,mPSD\[Theta],mPSDi,{u0Dim,rDropletDim,asymmetry,timeFactor,diffS},rEcoliShort,pthout,observables];*)
(**)
(*(** output scalars **)*)
(*{Flatten[{u0Dim,observables,velocityForceObservables}],mPSD\[Theta],mPSDi}*)
(*,{u0Dim,u0Dims}]\[Transpose];*)


(* ::Subsubsection::Closed:: *)
(*test: PSD fits*)


(* ::Input:: *)
(*parameterString="_rDroplet_5_3.50_rEcoli_0.5";*)
(*pthout=FileNameJoin[{NotebookDirectory[],"output_telegraph"}];*)
(*spectraTheta=Import[FileNameJoin[{pthout,"spectraTheta"<>parameterString<>".h5"}],"Dataset1"];*)
(*spectraI=Import[FileNameJoin[{pthout,"spectraIntensity"<>parameterString<>".h5"}],"Dataset1"];*)
(*simData=Import[FileNameJoin[{pthout,"simAnalysisData"<>parameterString<>".h5"}],"Dataset1"];*)


(* ::Input:: *)
(*fits=NonlinearModelFit[{freqs,#}\[Transpose],amp/( 1+(x-x0)^2/bb^2),{{amp,1},{bb,0.01},{x0,0.01}},x]&/@spectraTheta;*)
(*peakPositions=#["BestFitParameters"][[3,2]]&/@fits;*)
(**)
(*ops={AspectRatio->1,ImageSize->400,Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],ColorFunctionScaling->False,PlotRangePadding->{0,Scaled[0.05]},ImagePadding->{{70,15},{60,10}}};*)
(*fMax=2(*Max[freqs]*);  (** in Hz **)*)
(*pPSD\[Theta]=Show[*)
(*	ListLinePlot[{freqs,mPSD\[Theta]}\[Transpose],Evaluate[ops],FrameLabel->{"Frequency f (Hz)","PSD(\[Theta])"},PlotRange->{{0,fMax},All}]*)
(*	,Plot[\[Theta]Fit[x],{x,0,fMax},PlotStyle->Red,PlotRange->All]*)
(*]*)
(*pPSDi=Show[*)
(*	ListLinePlot[{freqs,mPSDi}\[Transpose],Evaluate[ops],FrameLabel->{"Frequency f (Hz)","PSD(i)"},PlotRange->{{0,fMax},All}]*)
(*	,Plot[iFit[x],{x,0,fMax},PlotStyle->Red,PlotRange->All]*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*check different fits*)


(* ::Input:: *)
(*Clear[\[Omega],\[Omega]0,amp,aa,bb,cc,i0];*)
(*fMax=1.0; (** found by eye where spectrum flattens out **)*)
(*fMaxIndex=FirstPosition[freqs,_?(#>=fMax&)][[1]];*)
(*{indexStart,indexEnd}={2,fMaxIndex};*)
(*{sFit,\[Theta]Fit,iFit}=NonlinearModelFit[{freqs,#}\[Transpose][[indexStart;;indexEnd]],aa/( 1+(x-x0)^2/bb^2),{{aa,1},{bb,0.01},{x0,0.01}},x]&/@{mPSDs,mPSD\[Theta],mPSDi};*)
(*\[Theta]FitTheory=NonlinearModelFit[{freqs,mPSD\[Theta]}\[Transpose][[indexStart;;indexEnd]],{aa^2/(1+(\[Omega]-\[Omega]0)^2/bb^2)^2,aa>0,bb>0,\[Omega]0>0},{{aa,1},{bb,0.1},{\[Omega]0,0.001}},\[Omega]];*)
(**)
(*(*iFitTheory=NonlinearModelFit[{freqs,#}\[Transpose]\[LeftDoubleBracket]indexStart;;indexEnd\[RightDoubleBracket],{i0^2 (\[Pi]^2/4+(2 aa^2 bb^3 Sqrt[2/\[Pi]])/(4 bb^2+(\[Omega]-2 \[Omega]0)^2)+(aa bb^2(2  cc Sqrt[2/\[Pi]]- \[Pi]))/(bb^2+(\[Omega]-\[Omega]0)^2))^2,aa>0,bb>0,cc>0,\[Omega]0>0},{{i0,0.01},{aa,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]1,2\[RightDoubleBracket]},{bb,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]2,2\[RightDoubleBracket]},{cc,1.01},{\[Omega]0,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]3,2\[RightDoubleBracket]}},\[Omega]]&@mPSDi;*)*)
(**)
(*weights=Table[1.0,{i,1,indexEnd-indexStart+1}];*)
(*(*weights=Table[If[i<100,1.0,0.1],{i,1,indexEnd-indexStart+1}];*)*)
(*(*If[i<100,1.0,0.1],{i,1,indexEnd-indexStart+1}];*)*)
(*(*weights=Table[Which[i<10,0.1,20\[LessEqual]i<100,1.0,True,0.1],{i,1,indexEnd-indexStart+1}];*)*)
(*(*weights=mPSDi\[LeftDoubleBracket]indexStart;;indexEnd\[RightDoubleBracket];*)*)
(*(*iFitTheory=NonlinearModelFit[{freqs,mPSDi}\[Transpose]\[LeftDoubleBracket]indexStart;;indexEnd\[RightDoubleBracket],{aa bb^2i0^2 ((2 aa bb Sqrt[2/\[Pi]])/(4 bb^2+(\[Omega]-2 \[Omega]0)^2)+(2  cc Sqrt[2/\[Pi]]- \[Pi])/(bb^2+(\[Omega]-\[Omega]0)^2))^2/.\[Theta]FitTheory["BestFitParameters"],cc>0},{{i0,0.1},{cc,2.1}},\[Omega],Weights\[Rule]weights];*)*)
(*(*iFitTheory=NonlinearModelFit[{freqs,mPSDi}\[Transpose]\[LeftDoubleBracket]indexStart;;indexEnd\[RightDoubleBracket],{i0^2 (1/(2520 Sqrt[2 \[Pi]])aa bb^2 (-((128 aa^7 bb^7)/(64 bb^2+(\[Omega]-8 \[Omega]0)^2))+(448 aa^6 bb^6 (-2 cc+\[Pi]))/(49 bb^2+(\[Omega]-7 \[Omega]0)^2)-(672 aa^5 bb^5 (-2+4 cc^2-4 cc \[Pi]+\[Pi]^2))/(36 bb^2+(\[Omega]-6 \[Omega]0)^2)+(560 aa^4 bb^4 (-8 cc^3+12 cc^2 \[Pi]+\[Pi] (-6+\[Pi]^2)-6 cc (-2+\[Pi]^2)))/(25 bb^2+(\[Omega]-5 \[Omega]0)^2)-(280 aa^3 bb^3 (24+16 cc^4-32 cc^3 \[Pi]-12 \[Pi]^2+\[Pi]^4-8 cc \[Pi] (-6+\[Pi]^2)+24 cc^2 (-2+\[Pi]^2)))/(16 bb^2+(\[Omega]-4 \[Omega]0)^2)-(84 aa^2 bb^2 (32 cc^5-80 cc^4 \[Pi]-40 cc^2 \[Pi] (-6+\[Pi]^2)+80 cc^3 (-2+\[Pi]^2)-\[Pi] (120-20 \[Pi]^2+\[Pi]^4)+10 cc (24-12 \[Pi]^2+\[Pi]^4)))/(9 bb^2+(\[Omega]-3 \[Omega]0)^2)-(1/(4 bb^2+(\[Omega]-2 \[Omega]0)^2))14 aa bb (-720+64 cc^6-192 cc^5 \[Pi]+360 \[Pi]^2-30 \[Pi]^4+\[Pi]^6-160 cc^3 \[Pi] (-6+\[Pi]^2)+240 cc^4 (-2+\[Pi]^2)-12 cc \[Pi] (120-20 \[Pi]^2+\[Pi]^4)+60 cc^2 (24-12 \[Pi]^2+\[Pi]^4))+1/(bb^2+(\[Omega]-\[Omega]0)^2)(-128 cc^7+448 cc^6 \[Pi]+560 cc^4 \[Pi] (-6+\[Pi]^2)-672 cc^5 (-2+\[Pi]^2)+84 cc^2 \[Pi] (120-20 \[Pi]^2+\[Pi]^4)-280 cc^3 (24-12 \[Pi]^2+\[Pi]^4)+\[Pi] (-5040+840 \[Pi]^2-42 \[Pi]^4+\[Pi]^6)-14 cc (-720+360 \[Pi]^2-30 \[Pi]^4+\[Pi]^6))))^2/.\[Theta]FitTheory["BestFitParameters"],\[Pi]/4<cc<\[Pi]},{{i0,0.1},{cc,2.1}},\[Omega],Weights\[Rule]weights];*)*)
(*(*iFitTheory=NonlinearModelFit[{freqs,mPSDi}\[Transpose]\[LeftDoubleBracket]indexStart;;indexEnd\[RightDoubleBracket],{i0^2 (1/(2520 Sqrt[2 \[Pi]])aa bb^2 (-((128 aa^7 bb^7)/(64 bb^2+(\[Omega]-8 \[Omega]0)^2))+(448 aa^6 bb^6 (-2 cc+\[Pi]))/(49 bb^2+(\[Omega]-7 \[Omega]0)^2)-(672 aa^5 bb^5 (-2+4 cc^2-4 cc \[Pi]+\[Pi]^2))/(36 bb^2+(\[Omega]-6 \[Omega]0)^2)+(560 aa^4 bb^4 (-8 cc^3+12 cc^2 \[Pi]+\[Pi] (-6+\[Pi]^2)-6 cc (-2+\[Pi]^2)))/(25 bb^2+(\[Omega]-5 \[Omega]0)^2)-(280 aa^3 bb^3 (24+16 cc^4-32 cc^3 \[Pi]-12 \[Pi]^2+\[Pi]^4-8 cc \[Pi] (-6+\[Pi]^2)+24 cc^2 (-2+\[Pi]^2)))/(16 bb^2+(\[Omega]-4 \[Omega]0)^2)-(84 aa^2 bb^2 (32 cc^5-80 cc^4 \[Pi]-40 cc^2 \[Pi] (-6+\[Pi]^2)+80 cc^3 (-2+\[Pi]^2)-\[Pi] (120-20 \[Pi]^2+\[Pi]^4)+10 cc (24-12 \[Pi]^2+\[Pi]^4)))/(9 bb^2+(\[Omega]-3 \[Omega]0)^2)-(1/(4 bb^2+(\[Omega]-2 \[Omega]0)^2))14 aa bb (-720+64 cc^6-192 cc^5 \[Pi]+360 \[Pi]^2-30 \[Pi]^4+\[Pi]^6-160 cc^3 \[Pi] (-6+\[Pi]^2)+240 cc^4 (-2+\[Pi]^2)-12 cc \[Pi] (120-20 \[Pi]^2+\[Pi]^4)+60 cc^2 (24-12 \[Pi]^2+\[Pi]^4))+1/(bb^2+(\[Omega]-\[Omega]0)^2)(-128 cc^7+448 cc^6 \[Pi]+560 cc^4 \[Pi] (-6+\[Pi]^2)-672 cc^5 (-2+\[Pi]^2)+84 cc^2 \[Pi] (120-20 \[Pi]^2+\[Pi]^4)-280 cc^3 (24-12 \[Pi]^2+\[Pi]^4)+\[Pi] (-5040+840 \[Pi]^2-42 \[Pi]^4+\[Pi]^6)-14 cc (-720+360 \[Pi]^2-30 \[Pi]^4+\[Pi]^6))))^2/.\[Theta]FitTheory["BestFitParameters"],\[Pi]/4<cc<\[Pi]},{{i0,0.1},{aa,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]1,2\[RightDoubleBracket]},{bb,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]2,2\[RightDoubleBracket]},{cc,2.1},{\[Omega]0,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]3,2\[RightDoubleBracket]}},\[Omega],Weights\[Rule]weights];*)*)
(*iFitTheory=NonlinearModelFit[{freqs,mPSDi}\[Transpose][[indexStart;;indexEnd]],{i0^2 (1/(2520 Sqrt[2 \[Pi]]) aa bb^2 (-((128 aa^7 bb^7)/(64 bb^2+(\[Omega]-8 \[Omega]0)^2))+(448 aa^6 bb^6 (-2 cc+\[Pi]))/(49 bb^2+(\[Omega]-7 \[Omega]0)^2)-(672 aa^5 bb^5 (-2+4 cc^2-4 cc \[Pi]+\[Pi]^2))/(36 bb^2+(\[Omega]-6 \[Omega]0)^2)+(560 aa^4 bb^4 (-8 cc^3+12 cc^2 \[Pi]+\[Pi] (-6+\[Pi]^2)-6 cc (-2+\[Pi]^2)))/(25 bb^2+(\[Omega]-5 \[Omega]0)^2)-(280 aa^3 bb^3 (24+16 cc^4-32 cc^3 \[Pi]-12 \[Pi]^2+\[Pi]^4-8 cc \[Pi] (-6+\[Pi]^2)+24 cc^2 (-2+\[Pi]^2)))/(16 bb^2+(\[Omega]-4 \[Omega]0)^2)-1/(9 bb^2+(\[Omega]-3 \[Omega]0)^2) 84 aa^2 bb^2 (32 cc^5-80 cc^4 \[Pi]-40 cc^2 \[Pi] (-6+\[Pi]^2)+80 cc^3 (-2+\[Pi]^2)-\[Pi] (120-20 \[Pi]^2+\[Pi]^4)+10 cc (24-12 \[Pi]^2+\[Pi]^4))-1/(4 bb^2+(\[Omega]-2 \[Omega]0)^2) 14 aa bb (-720+64 cc^6-192 cc^5 \[Pi]+360 \[Pi]^2-30 \[Pi]^4+\[Pi]^6-160 cc^3 \[Pi] (-6+\[Pi]^2)+240 cc^4 (-2+\[Pi]^2)-12 cc \[Pi] (120-20 \[Pi]^2+\[Pi]^4)+60 cc^2 (24-12 \[Pi]^2+\[Pi]^4))+1/(bb^2+(\[Omega]-\[Omega]0)^2) (-128 cc^7+448 cc^6 \[Pi]+560 cc^4 \[Pi] (-6+\[Pi]^2)-672 cc^5 (-2+\[Pi]^2)+84 cc^2 \[Pi] (120-20 \[Pi]^2+\[Pi]^4)-280 cc^3 (24-12 \[Pi]^2+\[Pi]^4)+\[Pi] (-5040+840 \[Pi]^2-42 \[Pi]^4+\[Pi]^6)-14 cc (-720+360 \[Pi]^2-30 \[Pi]^4+\[Pi]^6))))^2/.\[Theta]FitTheory["BestFitParameters"],\[Pi]/4<cc<3\[Pi]/4,aa>0,bb>0,0<\[Omega]0<1},{i0,aa,bb,cc,\[Omega]0},\[Omega],Weights->weights,MaxIterations->500,Method->{NMinimize}];*)
(*(*iFitTheory=NonlinearModelFit[{freqs,mPSDi}\[Transpose]\[LeftDoubleBracket]indexStart;;indexEnd\[RightDoubleBracket],{i0^2 (\[Pi]^2/4+(2 aa^2 bb^3 Sqrt[2/\[Pi]])/(4 bb^2+(\[Omega]-2 \[Omega]0)^2)+(aa bb^2(2  cc Sqrt[2/\[Pi]]- \[Pi]))/(bb^2+(\[Omega]-\[Omega]0)^2))^2/.\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]3\[RightDoubleBracket],cc>0},{{i0,0.0001},{aa,100\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]1,2\[RightDoubleBracket]},{bb,\[Theta]FitTheory["BestFitParameters"]\[LeftDoubleBracket]2,2\[RightDoubleBracket]},{cc,10.01}},\[Omega]];*)*)
(*{sWidth,\[Theta]Width,iWidth}=Abs[#["BestFitParameters"][[2,2]]]&/@{sFit,\[Theta]Fit,iFit};*)
(*Print[\[Theta]FitTheory["BestFitParameters"]];*)
(*Print[iFitTheory["BestFitParameters"]];*)
(*cFit=cc/.iFitTheory["BestFitParameters"];*)
(**)
(*(** plots **)*)
(*rEcoliShort=0.5*^-6/rDropletDim;  (**  rescaled radius of E. coli **)*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[times,fineTrajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,mPSD\[Theta],mPSDi,{u0Dim,rDropletDim,asymmetry,timeFactor,diffS},rEcoliShort,pthout,observables,debugPlotQ];*)


(* ::Input:: *)
(*Plot[\[Theta]FitTheory[x],{x,0,1},PlotRange->All]*)


(* ::Input:: *)
(*iFitTheory["ParameterTable"]*)


(* ::Input:: *)
(*Length@weights*)


(* ::Input:: *)
(*ListPlot[weights*mPSDi[[2;;202]]]*)


(* ::Input:: *)
(*{freqs,mPSDi}\[Transpose][[indexStart;;indexEnd]];*)


(* ::Input:: *)
(*ListPlot[freqs[[indexStart;;indexEnd]],Frame->True,AspectRatio->1,FrameStyle->Directive[Black,20]]*)


(* ::Input:: *)
(*{freqs,mPSDi}\[Transpose][[indexStart;;indexEnd]];*)


(* ::Input:: *)
(*ListPlot[{freqs,mPSDi}\[Transpose][[indexStart;;indexEnd]]]*)


(* ::Input:: *)
(*values=(*mPSDi*)Sort[{freqs,mPSDi}\[Transpose][[indexStart;;indexEnd]]];*)
(*peaks=FindPeaks[values,2,0.2]*)
(*ListLinePlot[{values,peaks},Joined->{True,False},PlotStyle->{Automatic,PointSize[.03]}]*)


(* ::Input:: *)
(*ListLinePlot[{freqs,mPSDi}\[Transpose][[indexStart;;indexEnd]],PlotRange->All]*)


(* ::Subsubsection::Closed:: *)
(*calculate effective noise spectrum*)


(* ::Input:: *)
(*result=calcMeanPowerSpectra[trajectories,dt,gravFactor];*)


(* ::Input:: *)
(*ListLogPlot[mPSD\[Theta],PlotRange->{10^-6,1000}]*)


(* ::Input:: *)
(*LogPlot[PowerSpectralDensity[thetaData,\[Omega]],{\[Omega],0,\[Pi]},PlotRange->All]*)


(* ::Input:: *)
(*Plot[PowerSpectralDensity[thetaNoise,\[Omega],10],{\[Omega],0,\[Pi]},PlotRange->All]*)


(* ::Input:: *)
(*LogPlot[PowerSpectralDensity[thetaNoise,\[Omega]],{\[Omega],0,\[Pi]},PlotRange->All,Frame->True,AspectRatio->1/2]*)


(* ::Input:: *)
(*meanTheta*)
(*ListLinePlot[thetaData,PlotRange->All,Frame->True,AspectRatio->1/2]*)
(*ListLinePlot[sData,PlotRange->All,Frame->True,AspectRatio->1/2]*)
(*ListLinePlot[thetaNoise,PlotRange->All,Frame->True,AspectRatio->1/2]*)
(*meanThetaNoise*)
(*ListLinePlot[CorrelationFunction[thetaNoise,{Length[thetaNoise]-1}][[2;;]],PlotRange->All,Frame->True,AspectRatio->1/2]*)
(*ListLinePlot[mThetaNoiseC[[2;;]],PlotRange->All,Frame->True,AspectRatio->1/2]*)
(*ListLinePlot[Abs@mThetaNoiseC[[2;;]],PlotRange->All,Frame->True,AspectRatio->1/2]*)
(*ListLogPlot[Abs[Fourier[mThetaNoiseC]][[2;;10000]],PlotRange->All,Frame->True,AspectRatio->1/2,Joined->True]*)


(* ::Subsubsection::Closed:: *)
(*spectra as a function of age*)


(* ::Input:: *)
(*rDropletDim=3.5*^-6;*)
(*rEcoliDim=0.5*^-6;*)
(*parameterString="_rDroplet_3_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_rEcoli_0.5";*)
(*pthout=FileNameJoin[{NotebookDirectory[],"output"}];*)
(*spectraTheta=Import[FileNameJoin[{pthout,"spectraTheta"<>parameterString<>".h5"}],"Dataset1"];*)
(*pthout=FileNameJoin[{NotebookDirectory[],"output"}];*)
(*spectraI=Import[FileNameJoin[{pthout,"spectraIntensity"<>parameterString<>".h5"}],"Dataset1"];*)


(* ::Input:: *)
(*spectraTheta//Dimensions*)


(* ::Input:: *)
(*ListLinePlot[spectraTheta[[10]],PlotRange->{{0,100},All}]*)


(* ::Input:: *)
(*u0Dim=1*^-6;*)
(*Sqrt[(swimFactor dragTransDim u0Dim(rDropletDim+rEcoliDim))^2-(m gDim rcomDim)^2]*)


(* ::Input:: *)
(*swimFactor=2.0;*)
(*freqMax[u0Dim_]:=(2\[Pi] dragDim)/Sqrt[(swimFactor dragTransDim u0Dim(rDropletDim+rEcoliDim))^2-(m gDim rcomDim)^2]*)
(*Plot[freqMax[20-x*1*^-6],{x,0,20}]*)


(* ::Input:: *)
(*fMaxIndex=100;*)
(*freqMax[u0Dim_]:=(2\[Pi] dragDim)/Sqrt[(swimFactor dragTransDim u0Dim(rDropletDim+rEcoliDim))^2-(m gDim rcomDim)^2]*)
(*Show[*)
(*ListDensityPlot[Reverse@spectraTheta[[All,;;fMaxIndex]]\[Transpose],InterpolationOrder->0,ColorFunction->"BlueGreenYellow",PlotLegends->Automatic(*"PSD(\[Theta])"*),FrameLabel->{"speed difference (m/s)","frequency f (Hz)"},PlotRange->All,FrameStyle->Directive[Black,20],PlotRangePadding->None,DataRange->{{0,20},{0,freqs[[fMaxIndex]]}}],*)
(*Plot[freqMax[20-x],{x,0,1},PlotStyle->Red]*)
(*]*)
(*Show[*)
(*ListDensityPlot[Reverse@spectraI[[All,;;100]]\[Transpose],InterpolationOrder->0,ColorFunction->"BlueGreenYellow",PlotLegends->Automatic(*"PSD(i)"*),FrameLabel->{"speed difference (m/s)","frequency f (Hz)"},FrameStyle->Directive[Black,20],PlotRangePadding->None,DataRange->{{0,20},{0,freqs[[fMaxIndex]]}}]*)
(*]*)


(* ::Input:: *)
(*ListDensityPlot[spectraI,InterpolationOrder->0,ColorFunction->"BlueGreenYellow",PlotLegends->"PSD(I)",FrameLabel->{"speed difference (m/s)","frequency f (Hz)"}]*)


(* ::Subsubsection::Closed:: *)
(*single simulation: C++ simulation call and output*)


(* ::Input:: *)
(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor}={20.0*^-6,3.5,120,0.2,7.0*^-6,15.0,1.0};  (** default **)*)
(*(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,c,swimFactor}={20.0*^-6,3.5,120,0.2,7.0*^-6,15.0,7.5};  (** well-fed **)*)*)
(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor}={20.0*^-6,3.5,120,0.2,7.0*^-6,15.0,5.0};  (** well-fed **)*)
(*(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,c,swimFactor}={20.0*^-6,3.5,0,0.2,7.0*^-6,15.0,7.0};*) (** starved - slow running **)*)
(*(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,c,swimFactor}={10.0*^-6,3.5,120,0.1,7.0*^-6,15.0,8.5}; *)     (** well-fed, slower **)*)
(*(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,c,swimFactor}={20.0*^-6,3.5,120,0.2,7.0*^-6,-25.0,1.0};*)     (** starved - tumbling **)*)
(*(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,c,swimFactor}={2.0*^-6,3.5,120,0.2,7.0*^-6,25.0,1.0};*)          (** starved - slow running - bad **)*)
(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor}={20.0*^-6,3.5,90,0.15,7.0*^-6,25.0,8.0};  (** starved - running **)*)
(*(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,c,swimFactor}={20.0*^-6,3.5,120,0.01,7.0*^-6,25.0,8.5}; *)*)
(**)
(*(** test: well-fed / active **)*)
(*{u0Dim,diffRot,rDropletDim,swimFactor}={20.0*^-6,3.5,3.5*^-6,2.0};*)
(*{diffS,timeFactor,asymmetry}={115,0.186,16.0}; *)
(*{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};*)
(*tTransient=Max[1,Round[0.2tfinalSim]];*)
(**)
(*(** test: starving / less active: more running **)*)
(*{u0Dim,diffRot,rDropletDim,swimFactor}={10.0*^-6,3.5,3.5*^-6,2.0};*)
(*{diffS,timeFactor,asymmetry}={115,0.186,30.0}; *)
(*{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};*)
(**)
(*(** run simulation **)*)
(*runSimulation[{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor,tfinalSim,nParallelSystems,noiseSeed}];*)
(**)
(*(** read simulation output **)*)
(*{nStepsFine,dtFine,timesFine,fineTrajectories,stepsTransient}=readSimulationOutput[tfinalSim,tTransient];*)
(*(*{nSteps,dt,times,trajectories}={nStepsFine/10,10dtFine,timesFine\[LeftDoubleBracket];;;;10\[RightDoubleBracket],fineTrajectories\[LeftDoubleBracket]All,;;;;10\[RightDoubleBracket]};*)*)
(*{nSteps,dt,times,trajectories}={nStepsFine,dtFine,timesFine[[;;;;1]],fineTrajectories[[All,;;;;1]]};*)
(**)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];*)
(*observables=Flatten[{Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes}];*)
(**)
(*fineTrajectory=fineTrajectories[[-1]];*)
(*trajectory=fineTrajectory[[;;;;1]];*)
(*sData=trajectory[[All,7]];*)
(**)
(*(*ops={AspectRatio\[Rule]1,ImageSize\[Rule]400,Frame\[Rule]True,FrameStyle\[Rule]Directive[Black,20,AbsoluteThickness[2]],ColorFunctionScaling\[Rule]False};*)
(*sPlot=ListLinePlot[{times,sData}\[Transpose],Evaluate[ops],FrameLabel\[Rule]{"Time t (s)","RT state s"},PlotRange\[Rule]{{0,60},{0,1}}];*)*)
(**)
(*descriptions={"mean \!\(\*SubscriptBox[\(T\), \(t\)]\)/\!\(\*SubscriptBox[\(T\), \(all\)]\) ratio","mean res time R","mean res time T"};*)
(*numericalStrings0=ToString[DecimalForm[#,{4,3}]]&/@observables;*)
(*numericalStrings=Flatten@Join[{#[[1]]<>"\[PlusMinus]"<>#[[2]]},#[[3;;]]]&@numericalStrings0;*)
(*plotData=Grid[{descriptions,numericalStrings}\[Transpose],Frame->All]*)
(**)
(*Histogram[sData,PlotRange->All]*)


(* ::Input:: *)
(*(** calculate mean power spectral densities, fit and width **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,sData,thetaData,phiData,iData}=calcMeanPowerSpectra[trajectories,dt];*)
(*Clear[x,x0,amp,bb];*)
(*{sFit,\[Theta]Fit,iFit}=NonlinearModelFit[{freqs,#}\[Transpose],amp/( 1+(x-x0)^2/bb^2),{{amp,1},{bb,0.1},{x0,0.01}},x]&/@{mPSDs,mPSD\[Theta],mPSDi};*)
(*{sWidth,\[Theta]Width,iWidth}=Abs[#["BestFitParameters"][[2,2]]]&/@{sFit,\[Theta]Fit,iFit};*)
(**)
(*(** plots **)*)
(*rEcoliShort=0.5*^-6/rDropletDim;*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[times,fineTrajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,mPSD\[Theta],mPSDi,{u0Dim,rDropletDim,asymmetry,timeFactor,diffS},rEcoliShort,(*""*)FileNameJoin[{NotebookDirectory[]}],observables];*)


(* ::Input:: *)
(*ops={AspectRatio->1,ImageSize->400,Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],ColorFunctionScaling->False(*,ColorFunction\[Rule]Function[{x,y},If[rtState\[LeftDoubleBracket]Round[x/dt]\[RightDoubleBracket]\[Equal]0,Darker@Gray,(*Darker@Gray*)tumbleColor]]*)};*)
(*ListLinePlot[trajectories[[;;,;;10000;;10,7]],Evaluate[ops],FrameLabel->{"time t (s)","s"},PlotRange->All]*)


(* ::Subsubsection::Closed:: *)
(*test: PSD of many trajectories*)


(* ::Input:: *)
(*rtRatios=N[Count[#,1]/nSteps]&/@rtStates;*)


(* ::Input:: *)
(*{rTimes1,rTimes2,tRates1,tRates2}=Table[*)
(*rtState=If[#<0.5,0,1]&/@trajectory[[All,7]];*)
(*rtRatio=N[#[[2,2]]/nSteps]&@Tally[rtState];*)
(*residenceData=Sort[{First[#],Length[#]}&/@Split[rtState]];*)
(*{data0,data1}=Reap[Do[Sow[d[[2]],If[d[[1]]==0,list0,list1]],{d,residenceData}]][[2]];*)
(*meanResidenceTimes=N[Mean/@{data0,data1}]dt;*)
(*meanTransitionRates=1/meanResidenceTimes;*)
(*Flatten[{meanResidenceTimes,meanTransitionRates}]*)
(*,{trajectory,trajectories}]\[Transpose];*)
(*meanStd/@{rTimes1,rTimes2,tRates1,tRates2};*)
(*meanResidenceTimes=Mean/@{rTimes1,rTimes2};*)
(*meanTransitionRates=Mean/@{tRates1,tRates2};*)


(* ::Input:: *)
(*times=Range[0,tfinal,dt];*)
(*psdData=Table[*)
(*sData=trajectory[[All,7]];*)
(*thetaData=\[Pi]-ArcCos[#[[3]]]&/@trajectory[[All,{1,2,3}]];*)
(*phiData=phaseUnwrap[ArcTan[#[[1]],#[[2]]]&/@trajectory[[All,{1,2}]]];*)
(*iData=Cos[#]^2&/@thetaData;*)
(*psds=calculateTemporalFreqSpectrum[dt,sData][[{1,2}]]\[Transpose];*)
(*psd\[Theta]=calculateTemporalFreqSpectrum[dt,thetaData][[{1,2}]]\[Transpose];*)
(*psdi=calculateTemporalFreqSpectrum[dt,iData][[{1,2}]]\[Transpose];*)
(*{psds,psd\[Theta],psdi}*)
(*,{trajectory,trajectories}];*)
(*freqs=psds[[All,1]];*)
(*mPSDs=Mean[psdData[[All,1,All,2]]];*)
(*mPSD\[Theta]=Mean[psdData[[All,2,All,2]]];*)
(*mPSDi=Mean[psdData[[All,3,All,2]]];*)
(*{sFit,\[Theta]Fit,iFit}=NonlinearModelFit[{freqs,#}\[Transpose],amp/( 1+(f)^2/b^2),{{amp,1},{b,0.1}},f]&/@{mPSDs,mPSD\[Theta],mPSDi};*)


(* ::Input:: *)
(*sFit["BestFitParameters"]*)
(*\[Theta]Fit["BestFitParameters"];*)
(*iFit["BestFitParameters"];*)
(*width=iFit["BestFitParameters"][[2,2]]*)


(* ::Input:: *)
(*fmax=(*1*)Max[freqs];*)
(*pPSDs=Show[ListLinePlot[{freqs,mPSDs}\[Transpose][[1;;]],Evaluate[ops],FrameLabel->{"frequency f (Hz)","PSD(s)"},PlotRange->{{0,fmax},All}],*)
(*Plot[sFit[x],{x,0,fmax},PlotStyle->Red,PlotRange->All],*)
(*Plot[(*0.045+3.5*) 2(1)^2/(Total[meanResidenceTimes](Total[meanTransitionRates]^2+(2\[Pi] f)^2)),{f,0,fmax},PlotStyle->Darker@Green,PlotRange->All]] (** Eq. 1.49 in Lindner's chapter for telegraph noise ~ to double potential noise spectrum **)*)
(*pPSD\[Theta]=Show[ListLinePlot[{freqs,mPSD\[Theta]}\[Transpose][[1;;]],Evaluate[ops],FrameLabel->{"frequency f (Hz)","PSD(\[Theta])"},PlotRange->{{0,fmax},All}],Plot[\[Theta]Fit[x],{x,0,fmax},PlotStyle->Red,PlotRange->All]]*)
(*pPSDi=Show[ListLinePlot[{freqs,mPSDi}\[Transpose][[1;;]],Evaluate[ops],FrameLabel->{"frequency f (Hz)","PSD(i)"},PlotRange->{{0,fmax},All}],Plot[iFit[x],{x,0,fmax},PlotStyle->Red,PlotRange->All]]*)


(* ::Input:: *)
(**)


(* ::Subsubsection::Closed:: *)
(*check different optical models I(\[Theta],\[Phi])*)


(* ::Input:: *)
(*{debugPlotQ,plotNoiseQ,detailedForceAnalysisQ}={False,False,False};*)
(*(** parameter values **)*)
(*{u0Dim,diffRotDim,rDropletDim,swimMultiplier,rEcoliShortDim}={5.0*^-6,3.5,3.5*^-6,1.0,0.5*^-6};*)
(*{diffS,timeFactor,asymmetry}={115,0.186,16.0}; *)
(*{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};*)
(*tTransient=Max[1,Round[0.2tfinalSim]];*)
(*hetQ=0;*)
(*{runTime0,tumbleTime0}={0.9,0.1};*)
(*(*{runTime0,tumbleTime0}={0.05,2};*)*)
(*rtRates={(1.0/runTime0)};*)
(*trRates={(1.0/tumbleTime0)};*)
(*u0Dims=({5} 1.0*^-6);*)
(*{rtRate,trRate}={rtRates[[1]],trRates[[1]]};*)
(**)
(*calcPhysicalParameters[u0Dim,rDropletDim];*)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(**)
(*(** run simulation **)*)
(*args={u0Dim,diffRotDim,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed,hetQ,rtRate,trRate};*)
(*runSimulation[args];*)
(**)
(*{nStepsFine,dtFine,timesFine,fineTrajectories}=readSimulationOutput[tfinalSim];                                                                                                            (** read simulation output **)*)
(*{nSteps,dt,times,trajectories}={nStepsFine,dtFine,timesFine[[;;;;1]],fineTrajectories[[All,;;;;1]]}; *)
(*stepsTransient=Round[tTransient/dt];*)


(* ::Input:: *)
(*tiltIntensityThetaPhi0={{-0.002289197653180697,0.16396500471606584`},{0.06779466671754819,0.32662198850855556`},{0.14789051171266698`,0.3545060428729823},{0.2413356642069724,0.3390149015594119},{0.31141952857770105`,0.31655274665473476`},{0.39485270044761656`,0.29021780642166506`},{0.4749485454427351,0.269304765648345},{0.5517070635630572,0.2406461542182396},{0.6217909279337863,0.21276209985381284`},{0.7018867729289049,0.1872017166864215},{0.7853199447988204,0.16473956178174443`},{0.8554038091695493,0.14150284981138872`},{0.9388369810394648,0.12291348023510423`},{1.0189328260345833`,0.10509866772449827`},{1.0956913441549054`,0.09038208347660626},{1.1757871891500242`,0.07798917042574999},{1.2492083803955498`,0.06791992857192913},{1.3359788791402616`,0.06017435791514403},{1.4127373972605841`,0.05320334432403728},{1.4894959153809053`,0.050105116061323285`},{1.5662544335012283`,0.050105116061323285`}};*)
(*\[Theta]ii0=Interpolation[{#[[1]],2.6#[[2]]}&/@tiltIntensityThetaPhi0,InterpolationOrder->1];*)
(**)
(*tiltIntensityThetaPhi45={{-0.004262108446307367,0.16379016416478503`},{0.07009248388037559,0.28584741923572954`},{0.15091269293111775`,0.3262404676764737},{0.2252672852578005,0.356096199132676},{0.3125531110326021,0.3745365038556245},{0.39014051172131436`,0.38331760134274273`},{0.47096072077205675`,0.37629272335304814`},{0.5517809298227989,0.3543399796352523},{0.6261355221494818,0.3350215651635921},{0.7004901144761644,0.3192155896867791},{0.7813103235269065,0.31833747993806727`},{0.8621305325776487,0.31482504094321995`},{0.9397179332663614,0.3016533947125425},{1.0108397172310144`,0.28584741923572954`},{1.0948927346437862`,0.2647727852666456},{1.169247326970469,0.2393076025540024},{1.2565331527452708`,0.21208620034393577`},{1.3308877450719538`,0.18486479813386897`},{1.4084751457606657`,0.1602777251699376},{1.4860625464493789`,0.13744687170343012`},{1.5701155638621505`,0.11900656698048162`}};*)
(*\[Theta]ii45=Interpolation[{#[[1]],2.6#[[2]]}&/@tiltIntensityThetaPhi45,InterpolationOrder->1];*)
(**)
(*tiltIntensityThetaPhi0={(*{-0.002289197653180697,0.16396500471606584`},*)*)
(*{-0.002289197653180697,2 0.16396500471606584`},*)
(*{0.032289197653180697,0.16396500471606584`},*)
(*{0.06779466671754819,0.32662198850855556`},{0.14789051171266698`,0.3545060428729823},{0.2413356642069724,0.3390149015594119},{0.31141952857770105`,0.31655274665473476`},{0.39485270044761656`,0.29021780642166506`},{0.4749485454427351,0.269304765648345},{0.5517070635630572,0.2406461542182396},{0.6217909279337863,0.21276209985381284`},{0.7018867729289049,0.1872017166864215},{0.7853199447988204,0.16473956178174443`},{0.8554038091695493,0.14150284981138872`},{0.9388369810394648,0.12291348023510423`},{1.0189328260345833`,0.10509866772449827`},{1.0956913441549054`,0.09038208347660626},{1.1757871891500242`,0.07798917042574999},{1.2492083803955498`,0.06791992857192913},{1.3359788791402616`,0.06017435791514403},{1.4127373972605841`,0.05320334432403728},{1.4894959153809053`,0.050105116061323285`},{1.5662544335012283`,0.050105116061323285`}};*)
(*\[Theta]ii0=Interpolation[{#[[1]],2.6#[[2]]}&/@tiltIntensityThetaPhi0,InterpolationOrder->1];*)
(**)
(*tiltIntensityThetaPhi45={(*{-0.004262108446307367,0.16379016416478503`},*)*)
(*{-0.002289197653180697,2 0.16396500471606584`},*)
(*{0.032289197653180697,0.16396500471606584`},*)
(*{0.07009248388037559,0.28584741923572954`},{0.15091269293111775`,0.3262404676764737},{0.2252672852578005,0.356096199132676},{0.3125531110326021,0.3745365038556245},{0.39014051172131436`,0.38331760134274273`},{0.47096072077205675`,0.37629272335304814`},{0.5517809298227989,0.3543399796352523},{0.6261355221494818,0.3350215651635921},{0.7004901144761644,0.3192155896867791},{0.7813103235269065,0.31833747993806727`},{0.8621305325776487,0.31482504094321995`},{0.9397179332663614,0.3016533947125425},{1.0108397172310144`,0.28584741923572954`},{1.0948927346437862`,0.2647727852666456},{1.169247326970469,0.2393076025540024},{1.2565331527452708`,0.21208620034393577`},{1.3308877450719538`,0.18486479813386897`},{1.4084751457606657`,0.1602777251699376},{1.4860625464493789`,0.13744687170343012`},{1.5701155638621505`,0.11900656698048162`}};*)
(*\[Theta]ii45=Interpolation[{#[[1]],2.6#[[2]]}&/@tiltIntensityThetaPhi45,InterpolationOrder->1];*)
(**)
(*thetas=Subdivide[0.,\[Pi]/2,Length[tiltIntensityThetaPhi45]-1];*)
(*phis=N@{0,\[Pi]/4};*)
(*tiltIntensityData={tiltIntensityThetaPhi0[[All,2]],tiltIntensityThetaPhi45[[All,2]]};*)
(*thetaPhiIntensity=Flatten[Table[{{thetas[[j]],phis[[i]]},tiltIntensityData[[i,j]]},{j,Length@thetas},{i,Length@phis}],1];*)
(*thetaPhiIntensityInterpolationSparse=Interpolation[thetaPhiIntensity,InterpolationOrder->{1,1}];*)
(**)
(*Show[*)
(*(*ListPlot[tiltIntensityThetaPhi45,PlotStyle->Black],*)*)
(*Plot[{\[Theta]ii0[\[Theta]],\[Theta]ii45[\[Theta]]},{\[Theta],0,\[Pi]/2},PlotLegends->{"Jones \[Phi]=0\[Degree]","Jones \[Phi]=45\[Degree]"}],*)
(*Plot[Cos[\[Theta]]^2,{\[Theta],0,\[Pi]/2},PlotStyle->Gray,PlotLegends->{"\!\(\*SuperscriptBox[\(cos\), \(2\)]\)\[Theta]"}](*,*)
(*Plot[0.5Sin[30\[Theta]]+Cos[\[Theta]]^2,{\[Theta],0,\[Pi]/2},PlotStyle->Red]*)*)
(*,PlotRange->{0,1},Frame->True,FrameLabel->{"polar angle \[Theta]","intensity I"},FrameStyle->Directive[Black,18],AspectRatio->1*)
(*]*)


(* ::Input:: *)
(*(** get info from all simulation trajectories **)*)
(*windowingQ=False;*)
(*nPadding=2Length[trajectories[[1]]];*)
(*padMemory=ConstantArray[0.0,nPadding];*)
(*psdData=Table[*)
(*sData=trajectory[[All,7]];*)
(*thetaData=ArcCos[#[[3]]]&/@trajectory[[All,{1,2,3}]];   (** 0 - top pole (z=+1), \[Pi] - bottom pole (z=-1) **)*)
(*phiData=phaseUnwrap[ArcTan[#[[1]],#[[2]]]&/@trajectory[[All,{1,2}]]];*)
(*iData=Cos[#]^2 &/@thetaData;*)
(*i2Data=(*0.5Sin[30#]+Cos[#]^2*)\[Theta]ii0[#] &/@thetaData;*)
(*i3Data=MapThread[thetaPhiIntensityInterpolation[#1,-Abs[Mod[#2,\[Pi]/2.0]-\[Pi]/4.0]+\[Pi]/4.0]&,{thetaData,phiData}];*)
(*meanTheta=Mean[thetaData];*)
(*{freqs,psd}=calculateTemporalFreqSpectrum[dt,sData,windowingQ,nPadding,padMemory][[{1,2}]];*)
(*psds={freqs,psd}\[Transpose];*)
(*psd\[Theta]=calculateTemporalFreqSpectrum[dt,thetaData,windowingQ,nPadding,padMemory][[{1,2}]]\[Transpose];*)
(*psdi=calculateTemporalFreqSpectrum[dt,iData,windowingQ,nPadding,padMemory][[{1,2}]]\[Transpose];*)
(*psdi2=calculateTemporalFreqSpectrum[dt,i2Data,windowingQ,nPadding,padMemory][[{1,2}]]\[Transpose];*)
(*psdi3=calculateTemporalFreqSpectrum[dt,i3Data,windowingQ,nPadding,padMemory][[{1,2}]]\[Transpose];*)
(*{psds,psd\[Theta],psdi,psdi2,psdi3,meanTheta,thetaData,iData,i2Data,i3Data}*)
(*,{trajectory,trajectories[[All,stepsTransient;;]]}];*)
(**)
(*(** average info **)*)
(*mPSDs=Mean[psdData[[All,1,All,2]]];                      (** averaged power spectral density of noise s **)*)
(*mPSD\[Theta]=Mean[psdData[[All,2,All,2]]];                      (** averaged power spectral density of polar angle \[Theta] **)*)
(*mPSDi=Mean[psdData[[All,3,All,2]]];                      (** averaged power spectral density of intensity i **)*)
(*mPSDi2=Mean[psdData[[All,4,All,2]]];                      (** averaged power spectral density of intensity i2 **)*)
(*mPSDi3=Mean[psdData[[All,5,All,2]]];                      (** averaged power spectral density of intensity i3 **)*)
(*stdPSD\[Theta]=StandardDeviation[psdData[[All,2,All,2]]];       (** standard deviation of power spectral density of polar angle \[Theta] **)*)
(*stdPSDi=StandardDeviation[psdData[[All,3,All,2]]];       (** standard deviation of power spectral density of intensity i **)*)
(*meanThetas=psdData[[All,6]];*)
(*thetaDatas=psdData[[All,7]];*)
(*iDatas=psdData[[All,8]];*)
(*i2Datas=psdData[[All,9]];*)
(*i3Datas=psdData[[All,10]];*)
(*meanMeanTheta=Mean[meanThetas];  (** scalar mean value of all theta time traces **)*)


(* ::Input:: *)
(*ops={Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],AspectRatio->1,ImageSize->{Automatic,300}};*)
(*ListPlot[{{freqs,mPSDi/Max[mPSDi]}\[Transpose],{freqs,mPSDi2/Max[mPSDi2]}\[Transpose],{freqs,mPSDi3/Max[mPSDi3]}\[Transpose]},Evaluate[ops],PlotLegends->{"\!\(\*SuperscriptBox[\(cos\), \(2\)]\)\[Theta]","Jones \[Theta]","Jones \[Theta],\[Phi]"},PlotRange->{{0,1},All},PlotStyle->{Opacity[1],Opacity[0.5]},Joined->True,FrameLabel->{"frequency \!\(\**)
(*StyleBox[\"f\",\nFontSlant->\"Italic\"]\) (Hz)","norm. PSD"}]*)


(* ::Input:: *)
(*ops={Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],AspectRatio->1,ImageSize->{Automatic,300}};*)
(*Manipulate[*)
(*(*p1=ListLinePlot[thetaDatas\[LeftDoubleBracket]i\[RightDoubleBracket],Evaluate[ops],ScalingFunctions->"Reverse",FrameLabel->{"step","\[Theta]"}];*)*)
(*p2=ListLinePlot[{iDatas[[i,stepsTransient;;]],i2Datas[[i,stepsTransient;;]],i3Datas[[i,stepsTransient;;]]},Evaluate[ops],(*PlotLegends->{"cos^2\[Theta]","Jones \[Theta]","Jones \[Theta],\[Phi]"},*)PlotStyle->{Opacity[1],Opacity[0.5]}];*)
(*p3=ListPlot[{psdData[[i,3]],psdData[[i,4]],psdData[[i,5]](*{#\[LeftDoubleBracket]1\[RightDoubleBracket],#\[LeftDoubleBracket]2\[RightDoubleBracket]/Max[psdData\[LeftDoubleBracket]i,3,All,2\[RightDoubleBracket]]}&/@psdData\[LeftDoubleBracket]i,3\[RightDoubleBracket],{#\[LeftDoubleBracket]1\[RightDoubleBracket],#\[LeftDoubleBracket]2\[RightDoubleBracket]/Max[psdData\[LeftDoubleBracket]i,4,All,2\[RightDoubleBracket]]}&/@psdData\[LeftDoubleBracket]i,4\[RightDoubleBracket],{#\[LeftDoubleBracket]1\[RightDoubleBracket],#\[LeftDoubleBracket]2\[RightDoubleBracket]/Max[psdData\[LeftDoubleBracket]i,5,All,2\[RightDoubleBracket]]}&/@psdData\[LeftDoubleBracket]i,5\[RightDoubleBracket]*)},Evaluate[ops],PlotLegends->{"\!\(\*SuperscriptBox[\(cos\), \(2\)]\)\[Theta]","Jones","Jones \[Theta],\[Phi]"},PlotRange->{{-0.01,1},All},PlotStyle->{Opacity[1],Opacity[0.5],Opacity[0.4]},Joined->True];*)
(*Grid[{{(*p1,*)p2,p3}}]*)
(*,{{i,37},1,Length[trajectories],1,Appearance->"Open"},TrackedSymbols:>{i}]*)


(* ::Input:: *)
(*Histogram[thetaDatas[[14,stepsTransient;;]],{0,\[Pi]/2,\[Pi]/(2 50)}]*)


(* ::Subsection::Closed:: *)
(*scan: single simulation*)


(* ::Subsubsection:: *)
(*run simulation*)


(* ::Input:: *)
(*{debugPlotQ,plotNoiseQ,detailedForceAnalysisQ}={False,False,False};*)
(**)
(*(** parameter values **)*)
(*tTransient=Max[1,Round[0.2tfinalSim]];*)
(*hetQ=0;*)
(*(*hetQ=1;*)*)
(**)
(*(** 10 um/s - slightly wider; 20 um/s - shorter **)*)
(*(*{u0Dim,runTime0,tumbleTime0}={5.0*^-6,0.9,0.1}; *)       (** young bacterium **)*)
(*{u0Dim,runTime0,tumbleTime0}={10.0*^-6,0.2,0.5};          (** works for young bacterium w=0.18! **)*)
(*{u0Dim,runTime0,tumbleTime0}={5.0*^-6,0.9,0.1};            (** aged bacterium;  w=0.10! **)*)
(*{u0Dim,runTime0,tumbleTime0}={20.0*^-6,0.1,(*0.*)1.0};            (** test for young bacteria **)*)
(*(*{u0Dim,runTime0,tumbleTime0}={10.0*^-6,0.2,(*0.*)0.2}; *)           (** test for young bacteria **)*)
(*(*parameterSubString="_test_lc_grav_leash_28b";*)*)
(*parameterSubString="_test_wl_code";*)
(*fudgeFactor=1.0;*)
(*{rtRate,trRate}=1/{runTime0,tumbleTime0};*)
(*(*{rtRate,trRate}={rtRates[[3]],trRates[[1]]};*)*)
(**)
(*Print[{"\!\(\*SubscriptBox[\(r\), \(droplet\)]\) (\[Mu]m)","\!\(\*SubscriptBox[\(u\), \(0\)]\) (\[Mu]m/s)"}," = ",10^6{rDropletDim,u0Dim}];*)
(*calcPhysicalParameters[u0Dim,rDropletDim];*)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(**)
(*(** run simulation **)*)
(*args={u0Dim,diffRotDim,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed,hetQ,rtRate,trRate};*)
(*Print["Simulation runtime: ",AbsoluteTiming[runSimulation[args];][[1]],"\[ThinSpace]s"];*)
(**)
(*(** read simulation output and get time information **)*)
(*{nSteps,dt,times,trajectories,stepsTransient}=readSimulationOutput[tfinalSim,tTransient];*)


(* ::Subsubsection:: *)
(*analyze trajectories / spectra*)


(* ::Input:: *)
(*(** calculate transition statistics to match to simulation to experimental values **)*)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];*)
(**)
(*(** calculate mean power spectral densities, fit and width **)*)
(*pathLookupMap=FileNameJoin[{NotebookDirectory[],"..","Data","numerical_droplet_optics","lookup_map"}];*)
(*thetaPhiIntensityInterpolation=updateIntensityLookupMap[pathLookupMap];*)
(*Print[AbsoluteTiming[*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,sData,thetaData,phiData,iData,phasesS,phases\[Theta],phasesI,*)
(*meanThetas,meanMeanTheta,thetaNoise,mThetaNoiseMean,mThetaNoiseC,meanIminmax,histoTheta}=calcMeanPowerSpectra[trajectories,dt,gravFactor,plotNoiseQ,stepsTransient];*)
(*][[1]]];*)
(**)
(*fMax=1.0; (** found by eye where spectrum flattens out **)*)
(*{sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,sWidth,\[Theta]Width,iWidth,meanThetaFit}=calcFits[fMax,freqs,mPSDs,mPSD\[Theta],mPSDi];*)
(**)
(*(** individual plots **)*)
(*outputName="test";*)
(*pthout=FileNameJoin[{NotebookDirectory[],"output",outputName}];*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[parameterSubString,times,trajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,meanThetas,rEcoliShort,pthout,observables,debugPlotQ,histoTheta,fMax];*)


(* ::Subsection::Closed:: *)
(*scan: swim speeds / droplet radii*)


(* ::Input:: *)
(*{debugPlotQ,plotNoiseQ,detailedForceAnalysisQ,showTransientQ}={False,False,False,False};*)
(**)
(*(** parameter values **)*)
(*{diffRotDim,rDropletDim,swimMultiplier,rEcoliShortDim}={3.5,3.5*^-6,1.0,0.5*^-6};*)
(*{diffS,timeFactor,asymmetry}={115,0.186,16.0}; *)
(*{tfinalSim,nParallelSystems,noiseSeed}={200,200,0};*)
(*tTransient=Max[1,Round[tfinalSim/5.0]];*)
(*hetQ=0;*)
(*fMax=1.0; (** found by eye where spectrum flattens out **)*)
(*rDropletDims=(*Range[1.0,3.5,0.1]*1.0*^-6*){3.5*1*^-6};*)
(*(*{runTime0,tumbleTime0}={0.9,0.1};*)*)
(*(*{runTime0,tumbleTime0}={0.15,0.4};*)*)
(*(*{runTime0,tumbleTime0}={0.3,0.4};*)*)
(*{runTime0,tumbleTime0}={0.2,0.4};*)
(*{rtRate,trRate}=1/{runTime0,tumbleTime0};*)
(*u0Dims=(((*{0.5}~Join~*)Range[1,15,1]) 1.0*^-6);*)
(**)
(*outputName="output_fig4_scan_test"(*"output_fixed_tttr_variable_speed"*)(*"output_telegraph_swimFactor_1_velocity_test"*)(*"output_bistable_u0Distro"*)(*"output_telegraph_medium_distribution_4"*);*)
(*pthout=FileNameJoin[{NotebookDirectory[],"output",outputName}];*)
(*If[!DirectoryQ[#],CreateDirectory[#]]&@pthout;*)
(*Print[AbsoluteTiming[*)
(*Do[*)
(*{simData,velocityForceObservables,spectraTheta,spectraI,spectraThetaNoise}=Table[*)
(*Print[{"\!\(\*SubscriptBox[\(r\), \(droplet\)]\) (\[Mu]m)","\!\(\*SubscriptBox[\(u\), \(0\)]\) (\[Mu]m/s)"}," = ",10^6{rDropletDim,u0Dim}];*)
(*calcPhysicalParameters[u0Dim,rDropletDim];*)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(**)
(*(** run simulation **)*)
(*args={u0Dim,diffRotDim,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed,hetQ,rtRate,trRate};*)
(*runSimulation[args];*)
(**)
(*stepSize=1;*)
(*{nSteps,dt,times,trajectories}=readSimulationOutput[tfinalSim,stepSize];                  (** read simulation output **)*)
(*stepsTransient=Round[tTransient/dt];*)
(*analyzeHeterogeneityData[u0Dim,hetQ,pthout];*)
(**)
(*(** calculate transition statistics to match to simulation to experimental values **)*)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];                                 *)
(**)
(*(** calculate mean power spectral densities, fit and width **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,sData,thetaData,phiData,iData,phaseS,phase\[Theta],phaseI,meanThetas,meanTheta,thetaNoise,meanThetaNoise,mThetaNoiseC}=calcMeanPowerSpectra[trajectories,dt,gravFactor,plotNoiseQ,stepsTransient];*)
(*velocityForceObservablesIndividual=If[detailedForceAnalysisQ,calcTangentVelocitiesForces[trajectories,dt,swimFactor,gravFactor,rDropletDim],{}];*)
(*(** get all intensity data **)*)
(*iDatas=#^2&/@trajectories[[All,3]];*)
(*Export[FileNameJoin[{pthout,"simulation_intensities_u0_"<>ToString[DecimalForm[10^6 u0Dim,{3,2}]]<>"_rDroplet_"<>ToString[DecimalForm[10^6 rDropletDim,{3,2}]]<>".hdf5"}],{times,iDatas},{"Datasets","times","intensities"}];*)
(**)
(*(** plot effective noise in theta **)*)
(*doNoiseAnalysisPlots[plotNoiseQ,thetaNoise,mThetaNoiseC,thetaData];*)
(**)
(*{sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,sWidth,\[Theta]Width,iWidth,meanThetaFit}=calcFits[fMax,freqs,mPSDs,mPSD\[Theta],mPSDi];*)
(**)
(*(** individual plots **)*)
(*parameterSubString="_u0_"<>ToString[DecimalForm[u0Dim 1*^6,{3,2}]]*)
(*	<>"_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]*)
(*	<>"_tR_"<>ToString[DecimalForm[1/rtRate,{5,4}]]*)
(*	<>"_tT_"<>ToString[DecimalForm[1/trRate,{5,4}]];*)
(*rEcoliShort=rEcoliShortDim/rDropletDim;  (**  rescaled radius of E. coli **)*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[parameterSubString,times,fineTrajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,meanThetas,rEcoliShort,pthout,observables,debugPlotQ,fMax];*)
(**)
(*(** output scalars **)*)
(*keys={"u0Dim","thetaWidth","iWidth","mRTratios","stdRTratios","meanRunTime","meanTumbleTime","meanRTRate","meanTRRate","meanTheta","meanThetaNoise","meanThetaFit"};*)
(*vals=Flatten[{u0Dim,observables,meanTheta,meanThetaNoise,meanThetaFit}];*)
(*individualSimData=Association[Thread[keys->vals]];*)
(*{individualSimData,velocityForceObservablesIndividual,mPSD\[Theta],mPSDi,mThetaNoiseC}*)
(*,{u0Dim,u0Dims}]\[Transpose];*)
(**)
(*(** overview plots **)*)
(*u0MaxMicron=Max[u0Dims] 1.0*^6;*)
(*parameterString="_rDroplet_5_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_rEcoli_0.5";*)
(*doOverviewPlotsSaveData[parameterString,simData,pthout,u0Dims,spectraTheta,spectraI,freqs,fMax,u0MaxMicron];*)
(**)
(*,{rDropletDim,rDropletDims}]; *)
(*][[1]],"\[ThinSpace]s"];*)


(* ::Subsection::Closed:: *)
(*scan: droplet radii, run/tumble rates*)


(* ::Input:: *)
(*{debugPlotQ,plotNoiseQ,detailedForceAnalysisQ,showTransientQ}={False,False,False,False};*)
(*outputName="check_fudge_friction_0.5_rDropletDimScan";*)
(*(*nameLookupMap="Fakerefindex_zDistance_1.5_gamma_1.0_NA_0.25";*)*)
(*nameLookupMap="RGB";*)
(*updateIntensityLookupMap[nameLookupMap];*)
(**)
(*(** parameter values **)*)
(*tTransient=Max[1,Round[0.2tfinalSim]];*)
(*hetQ=0;*)
(*fMax=1.0; (** found by eye where spectrum flattens out **)*)
(**)
(*(** good **)*)
(*{runTime0,tumbleTime0}={0.9,0.1};   (** s **)*)
(*(*rtRates=1/log10Subdivide[0.1#,10#,10-1]&@runTime0;*)
(*trRates=1/log10Subdivide[0.1#,10#,10-1]&@tumbleTime0;*)*)
(*rtRates=1/log10Subdivide[0.1#,10#,3-1]&@runTime0;*)
(*trRates=1/log10Subdivide[0.1#,10#,3-1]&@tumbleTime0;*)
(*u0Dim=20 1.0*^-6;*)
(*rDropletDims=Range[3.0,7.0,0.5] 1.0*^-6;*)
(**)
(**)
(*pthout=FileNameJoin[{NotebookDirectory[],"output",outputName}];*)
(*If[!DirectoryQ[#],CreateDirectory[#]]&@pthout;*)
(*Print[Overlay[{ProgressIndicator[Dynamic[pi],{0,1}],Dynamic[ToString@(NumberForm[pi*100,{4,1}])<>" %"]},Alignment->"Center"]];*)
(*Print[AbsoluteTiming[*)
(*pi=0;*)
(*counter=0;*)
(*Do[*)
(*{simData,velocityForceObservables,spectraTheta,spectraI,spectraThetaNoise}=Flatten[Table[*)
(*Print[{"\!\(\*SubscriptBox[\(r\), \(droplet\)]\) (\[Mu]m)","\!\(\*SubscriptBox[\(u\), \(0\)]\) (\[Mu]m/s)","\!\(\*SubscriptBox[\(t\), \(R\)]\) (s)","\!\(\*SubscriptBox[\(t\), \(T\)]\) (s)"}," = ",{DecimalForm[10^6rDropletDim,{2,1}],DecimalForm[10^6u0Dim,{3,2}],1/rtRate,1/trRate}];*)
(*calcPhysicalParameters[u0Dim,rDropletDim];*)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(**)
(*(** run simulation **)*)
(*args={u0Dim,diffRotDim,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed,hetQ,rtRate,trRate};*)
(*runSimulation[args];*)
(**)
(*(** read simulation output **)*)
(*{nSteps,dt,times,trajectories,stepsTransient}=readSimulationOutput[tfinalSim,tTransient,stepSize];                                  *)
(*analyzeHeterogeneityData[u0Dim,hetQ,pthout];*)
(**)
(*(** calculate transition statistics to match simulation to experimental values **)*)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];                                 *)
(**)
(*(** calculate mean power spectral densities, fit and width **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,sData,thetaData,phiData,iData,phaseS,phase\[Theta],phaseI,meanThetas,meanTheta,thetaNoise,meanThetaNoise,mThetaNoiseC,meanIminmax,histoTheta}=calcMeanPowerSpectra[trajectories,dt,gravFactor,plotNoiseQ,stepsTransient];*)
(*velocityForceObservablesIndividual=If[detailedForceAnalysisQ,calcTangentVelocitiesForces[trajectories,dt,swimFactor,gravFactor,rDropletDim],{}];*)
(**)
(*(** plot effective noise in theta **)*)
(*doNoiseAnalysisPlots[plotNoiseQ,thetaNoise,mThetaNoiseC,thetaData];*)
(*{sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,sWidth,\[Theta]Width,iWidth,meanThetaFit}=calcFits[fMax,freqs,mPSDs,mPSD\[Theta],mPSDi];*)
(**)
(*(** individual plots **)*)
(*parameterSubString="_u0_"<>ToString[DecimalForm[u0Dim 1*^6,{3,2}]]*)
(*	<>"_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]*)
(*	<>"_tR_"<>ToString[DecimalForm[1/rtRate,{5,4}]]*)
(*	<>"_tT_"<>ToString[DecimalForm[1/trRate,{5,4}]];*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[parameterSubString,times,trajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,meanThetas,rEcoliShort,pthout,observables,debugPlotQ,histoTheta,fMax];*)
(**)
(*(** output scalars **)*)
(*keys={"tRun","tTumble","u0Dim","thetaWidth","iWidth","mRTratios","stdRTratios","meanRunTime","meanTumbleTime","meanRTRate","meanTRRate","meanTheta","meanThetaNoise","meanThetaFit","iminmax"};*)
(*vals=Flatten[{1/rtRate,1/trRate,u0Dim,observables,meanTheta,meanThetaNoise,meanThetaFit,meanIminmax}];*)
(*individualSimData=Association[Thread[keys->vals]];*)
(*pi=N[++counter/(Length[rtRates]Length[trRates]Length[rDropletDims])];*)
(**)
(*{individualSimData,velocityForceObservablesIndividual,mPSD\[Theta],mPSDi,mThetaNoiseC}*)
(*,{rtRate,rtRates}*)
(*,{trRate,trRates}*)
(*],1]\[Transpose];*)
(**)
(*(** overview plots **)*)
(*u0Max=10.0;*)
(*parameterString="_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_u0Dim_"<>ToString[DecimalForm[u0Dim 1*^6,{3,2}]];*)
(*doOverviewPlotsSaveDataRT[parameterString,simData,pthout,rDropletDims,spectraTheta,spectraI,freqs,fMax,u0Max];*)
(**)
(*,{rDropletDim,rDropletDims}]; *)
(*][[1]],"\[ThinSpace]s"];*)


(* ::Subsection:: *)
(*scan: swim speeds, run/tumble rates*)


(* ::Subsubsection::Closed:: *)
(*parameter history*)


(* ::Input:: *)
(*(*{runTime0,tumbleTime0}={0.9,0.1}; *)  (** s **)*)


(* ::Subsubsection:: *)
(*main code*)


(* ::Input:: *)
(*{debugPlotQ,plotNoiseQ,detailedForceAnalysisQ,showTransientQ}={False,False,False,False};*)
(*outputName="production_fudge_friction_0.3_u0_1_14_pc_meep_slower_n1000";*)
(*pathLookupMap=FileNameJoin[{NotebookDirectory[],"..","Data","numerical_droplet_optics","lookup_map"}];*)
(*thetaPhiIntensityInterpolation=updateIntensityLookupMap[pathLookupMap];*)
(**)
(*(** parameter values **)*)
(*tTransient=Max[1,Round[0.2tfinalSim]];*)
(*hetQ=0;*)
(*fMax=1.0; (** found by eye where spectrum flattens out **)*)
(**)
(*(** good **)*)
(*{ntRun,ntTumble}=10{1,1};*)
(*{runTime0,tumbleTime0}={1.0,0.1};   (** s **)*)
(*rtRates=1/log10Subdivide[0.01#,10#,ntRun-1]&@runTime0;*)
(*trRates=1/log10Subdivide[0.01#,10#,ntTumble-1]&@tumbleTime0;*)
(*u0Dims=({0.1}~Join~Range[1,14,1]) 1.0*^-6;*)
(**)
(**)
(*pthout=FileNameJoin[{NotebookDirectory[],"output",outputName}];*)
(*If[!DirectoryQ[#],CreateDirectory[#]]&@pthout;*)
(**)
(*nIterations=Length[rtRates]Length[trRates]Length[u0Dims];*)
(*progressIndicatorRemainingTime[];*)
(*Print[AbsoluteTiming[*)
(*Do[*)
(*{simData,velocityForceObservables,spectraTheta,spectraI,spectraThetaNoise}=Flatten[Table[*)
(*Print[{"\!\(\*SubscriptBox[\(r\), \(droplet\)]\) (\[Mu]m)","\!\(\*SubscriptBox[\(u\), \(0\)]\) (\[Mu]m/s)","\!\(\*SubscriptBox[\(t\), \(R\)]\) (s)","\!\(\*SubscriptBox[\(t\), \(T\)]\) (s)"}," = ",{10^6rDropletDim,DecimalForm[10^6u0Dim,{3,2}],1/rtRate,1/trRate}];*)
(*calcPhysicalParameters[u0Dim,rDropletDim];*)
(*{swimFactor,gravFactor}=calcForceFactors[rDropletDim,u0Dim,swimMultiplier];*)
(*fudgeFactor=(*0.194545*)0.3(*0.53*);*)
(*(** run simulation **)*)
(*args={u0Dim,diffRotDim,diffS,timeFactor,rDropletDim,asymmetry,swimMultiplier,tfinalSim,nParallelSystems,noiseSeed,hetQ,rtRate,trRate,fudgeFactor};*)
(*runSimulation[args];*)
(**)
(*(** read simulation output **)*)
(*{nSteps,dt,times,trajectories,stepsTransient}=readSimulationOutput[tfinalSim,tTransient];*)
(*analyzeHeterogeneityData[u0Dim,hetQ,pthout];*)
(**)
(*(** calculate transition statistics to match simulation to experimental values **)*)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];                                 *)
(**)
(*(** calculate mean power spectral densities, fit and width **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,sData,thetaData,phiData,iData,phaseS,phase\[Theta],phaseI,meanThetas,meanTheta,thetaNoise,meanThetaNoise,mThetaNoiseC,meanIminmax,histoTheta}=calcMeanPowerSpectra[trajectories,dt,gravFactor,plotNoiseQ,stepsTransient];*)
(*velocityForceObservablesIndividual=If[detailedForceAnalysisQ,calcTangentVelocitiesForces[trajectories,dt,swimFactor,gravFactor,rDropletDim],{}];*)
(*(** get all intensity data **)*)
(*(*iDatas=#^2&/@trajectories\[LeftDoubleBracket]All,3\[RightDoubleBracket];*)
(*Export[FileNameJoin[{pthout,"simulation_intensities_u0_"<>ToString[DecimalForm[10^6 u0Dim,{3,2}]]<>"_rDroplet_"<>ToString[DecimalForm[10^6 rDropletDim,{3,2}]]<>".hdf5"}],{times,iDatas},{"Datasets","times","intensities"}];*)*)
(**)
(*(** plot effective noise in theta **)*)
(*doNoiseAnalysisPlots[plotNoiseQ,thetaNoise,mThetaNoiseC,thetaData];*)
(*{sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,sWidth,\[Theta]Width,iWidth,meanThetaFit}=calcFits[fMax,freqs,mPSDs,mPSD\[Theta],mPSDi];*)
(**)
(*(** individual plots **)*)
(*parameterSubString="_u0_"<>ToString[DecimalForm[u0Dim 1*^6,{3,2}]]*)
(*	<>"_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]*)
(*	<>"_tR_"<>ToString[DecimalForm[1/rtRate,{5,4}]]*)
(*	<>"_tT_"<>ToString[DecimalForm[1/trRate,{5,4}]];*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[parameterSubString,times,trajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,\[Theta]FitTheory,iFitTheory,mPSD\[Theta],mPSDi,stdPSD\[Theta],stdPSDi,meanThetas,rEcoliShort,pthout,observables,debugPlotQ,histoTheta,fMax];*)
(**)
(*(** output scalars **)*)
(*keys={"tRun","tTumble","u0Dim","thetaWidth","iWidth","mRTratios","stdRTratios","meanRunTime","meanTumbleTime","meanRTRate","meanTRRate","meanTheta","meanThetaNoise","meanThetaFit","iminmax"};*)
(*vals=Flatten[{1/rtRate,1/trRate,u0Dim,observables,meanTheta,meanThetaNoise,meanThetaFit,meanIminmax}];*)
(*individualSimData=Association[Thread[keys->vals]];*)
(*updateProgressIndicator[nIterations];*)
(**)
(*{individualSimData,velocityForceObservablesIndividual,mPSD\[Theta],mPSDi,mThetaNoiseC}*)
(*,{rtRate,rtRates}*)
(*,{trRate,trRates}*)
(*],1]\[Transpose];*)
(**)
(*(** overview plots **)*)
(*u0Max=Max[u0Dims] 1.0*^6;*)
(*parameterString="_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_u0Dim_"<>ToString[DecimalForm[u0Dim 1*^6,{3,2}]];*)
(*doOverviewPlotsSaveDataRT[parameterString,simData,pthout,u0Dims,spectraTheta,spectraI,freqs,fMax,u0Max];*)
(**)
(*,{u0Dim,u0Dims}]; *)
(*][[1]],"\[ThinSpace]s"];*)


(* ::Subsection::Closed:: *)
(*loop over asymmetry/diffS*)


(* ::Input:: *)
(*simData=Import[FileNameJoin[{NotebookDirectory[],"output","simAnalysisData_rDroplet_"<>ToString[DecimalForm[N@rd,{4,2}]]<>"_rEcoli_0.5.hdf5"}],{"Datasets","Dataset1"}];*)
(*simData[[All,All,3]]//Dimensions*)
(*Table[{diffS,asymmetry},{asymmetry,asymmetries},{diffS,diffSs}]//Dimensions*)


(* ::Input:: *)
(*asymmetries=Subdivide[0.0,50.0,10];*)
(*diffSs=Subdivide[50,150,10];*)
(*plotsWidth=Table[*)
(*Print[rd];*)
(*simData=Import[FileNameJoin[{NotebookDirectory[],"output","simAnalysisData_rDroplet_"<>ToString[DecimalForm[N@rd,{4,2}]]<>"_rEcoli_0.5.hdf5"}],{"Datasets","Dataset1"}];*)
(*data=MapThread[{#1[[1]],#1[[2]],#2}&,{Flatten[Table[{diffS,asymmetry},{asymmetry,asymmetries},{diffS,diffSs}],1],Flatten[simData[[All,All,3]]]}];*)
(*ListDensityPlot[data,FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"]*)
(*,{rd,Range[3,10,1]}]*)


(* ::Input:: *)
(*ListDensityPlot[Flatten[simData[[All,All,{1,2,3}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"]*)


(* ::Input:: *)
(*plotWidth=ListDensityPlot[simData[[All,All,{1,2,3}]],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"]*)


(* ::Input:: *)
(*parameterString="_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_rEcoli_0.5";*)
(*plotWidth=ListDensityPlot[Flatten[simData[[All,All,{1,2,3}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"];*)
(*plotRatios=ListDensityPlot[Flatten[simData[[All,All,{1,2,4}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"];*)
(*Print[Grid[{{plotWidth,plotRatios}}]];*)


(* ::Input:: *)
(*pthout=FileNameJoin[{NotebookDirectory[],"output"}];*)
(*If[!DirectoryQ[#],CreateDirectory[#]]&@pthout;*)
(*Print[AbsoluteTiming[*)
(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor,tfinalSim,nParallelSystems,noiseSeed}={20.0*^-6,3.5,120,0.2,3.5*^-6,15.0,2.0,200.0,200,0};  (** well-fed **)*)
(*(*swimFactor=5.0;*)*)
(*(*diffS=120;*)*)
(*(*timeFactor=0.23;*)*)
(*timeFactor=0.186;*)
(*(*tfinalSim=60;*)*)
(*rDropletDims=Range[2.5,5.0,0.5]*1*^-6;*)
(*Do[*)
(**)
(*asymmetries=Subdivide[0.0,50.0,10]+1;*)
(*diffSs=Subdivide[50,150,10];*)
(*simData=Table[*)
(*(*Print[{timeFactor,asymmetry}];*)*)
(*Print[{diffS,asymmetry}];*)
(**)
(*(** run simulation **)*)
(*runSimulation[{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor,tfinalSim,nParallelSystems,noiseSeed}];*)
(**)
(*(** read simulation output **)*)
(*{nStepsFine,dtFine,timesFine,fineTrajectories}=readSimulationOutput[tfinalSim];*)
(*(*{nSteps,dt,times,trajectories}={nStepsFine/10,10dtFine,timesFine\[LeftDoubleBracket];;;;10\[RightDoubleBracket],fineTrajectories\[LeftDoubleBracket]All,;;;;10\[RightDoubleBracket]};*)*)
(*{nSteps,dt,times,trajectories}={nStepsFine,dtFine,timesFine[[;;;;1]],fineTrajectories[[All,;;;;1]]};*)
(**)
(*(** calculate transition statistics for theory **)*)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];*)
(**)
(*(** calculate mean power spectral densities, fit and width **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,sData,thetaData,phiData,iData}=calcMeanPowerSpectra[trajectories,dt];*)
(*Clear[x,x0,amp,bb];*)
(*{sFit,\[Theta]Fit,iFit}=NonlinearModelFit[{freqs,#}\[Transpose],amp/( 1+(x-x0)^2/bb^2),{{amp,1},{bb,0.01},{x0,0.01}},x]&/@{mPSDs,mPSD\[Theta],mPSDi};*)
(*{sWidth,\[Theta]Width,iWidth}=Abs[#["BestFitParameters"][[2,2]]]&/@{sFit,\[Theta]Fit,iFit};*)
(**)
(*(** plots **)*)
(*rEcoliShort=0.5*^-6/rDropletDim;*)
(*observables=Flatten[{\[Theta]Width,iWidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}];*)
(*doPlots[times,fineTrajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,mPSD\[Theta],mPSDi,{u0Dim,rDropletDim,asymmetry,timeFactor,diffS},rEcoliShort,pthout,observables];*)
(**)
(*(** output scalars **)*)
(*Flatten[{diffS,asymmetry,observables}]*)
(*,{asymmetry,asymmetries}*)
(*,{diffS,diffSs}];*)
(**)
(*(** overview plots **)*)
(*parameterString="_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_rEcoli_0.5";*)
(*plotWidth=ListDensityPlot[Flatten[simData[[All,All,{1,2,3}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"];*)
(*Export[FileNameJoin[{pthout,"overview_width"<>parameterString<>"."<>#}],plotWidth]&/@{"png"};*)
(*plotRatios=ListDensityPlot[Flatten[simData[[All,All,{1,2,4}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"noise intensity \!\(\*SubscriptBox[\(D\), \(s\)]\)","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"];*)
(*Export[FileNameJoin[{pthout,"overview_ratios"<>parameterString<>"."<>#}],plotRatios]&/@{"png"};*)
(*Print[Grid[{{plotWidth,plotRatios}}]];*)
(**)
(*(** save data **)*)
(*Export[FileNameJoin[{pthout,"simAnalysisData"<>parameterString<>".hdf5"}],simData];*)
(**)
(*,{rDropletDim,rDropletDims}]; *)
(*][[1]]];*)


(* ::Subsection::Closed:: *)
(*loop over asymmetry/timeFactor*)


(* ::Input:: *)
(*pthout=FileNameJoin[{NotebookDirectory[],"output"}];*)
(*If[!DirectoryQ[#],CreateDirectory[#]]&@pthout;*)
(*Print[AbsoluteTiming[*)
(*{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor,tfinalSim,nParallelSystems,noiseSeed}={20.0*^-6,3.5,120,0.2,7.0*^-6,15.0,5.0,200.0,200,0};  (** well-fed **)*)
(*(*swimFactor=5.0;*)*)
(*diffS=120;*)
(**)
(*rDropletDims=Range[3.0,10.0,1.0]*1*^-6;*)
(*Do[*)
(**)
(*asymmetries=Subdivide[0.0,50.0,10];*)
(*timeFactors=Subdivide[0.15,0.3,10];*)
(*simData=Table[*)
(*Print[{timeFactor,asymmetry}];*)
(**)
(*(** run simulation **)*)
(*runSimulation[{u0Dim,diffRot,diffS,timeFactor,rDropletDim,asymmetry,swimFactor,tfinalSim,nParallelSystems,noiseSeed}];*)
(**)
(*(** read simulation output **)*)
(*{nStepsFine,dtFine,timesFine,fineTrajectories}=readSimulationOutput[tfinalSim];*)
(*(*{nSteps,dt,times,trajectories}={nStepsFine/10,10dtFine,timesFine\[LeftDoubleBracket];;;;10\[RightDoubleBracket],fineTrajectories\[LeftDoubleBracket]All,;;;;10\[RightDoubleBracket]};*)*)
(*{nSteps,dt,times,trajectories}={nStepsFine,dtFine,timesFine[[;;;;1]],fineTrajectories[[All,;;;;1]]};*)
(**)
(*(** calculate transition statistics for theory **)*)
(*{rtRatios,meanResidenceTimes,meanTransitionRates}=calcStateStatistics[trajectories,nSteps,dt];*)
(**)
(*(** calculate mean power spectral densities, fit and width **)*)
(*{freqs,mPSDs,mPSD\[Theta],mPSDi,sData,thetaData,phiData,iData}=calcMeanPowerSpectra[trajectories,dt];*)
(*Clear[x,x0,amp,bb];*)
(*{sFit,\[Theta]Fit,iFit}=NonlinearModelFit[{freqs,#}\[Transpose],amp/( 1+(x-x0)^2/bb^2),{{amp,1},{bb,0.01},{x0,0.01}},x]&/@{mPSDs,mPSD\[Theta],mPSDi};*)
(*\[Theta]width=\[Theta]Fit["BestFitParameters"][[2,2]];*)
(*iwidth=iFit["BestFitParameters"][[2,2]];*)
(**)
(*(** plots **)*)
(*rEcoliShort=0.5*^-6/rDropletDim;*)
(*doPlots[times,fineTrajectories[[-1]],tfinalSim,freqs,mPSDs,sFit,\[Theta]Fit,iFit,mPSD\[Theta],mPSDi,{u0Dim,rDropletDim,asymmetry,timeFactor,diffS},rEcoliShort,pthout];*)
(**)
(*(** output scalars **)*)
(*Flatten[{timeFactor,asymmetry,iwidth,Mean[rtRatios],StandardDeviation[rtRatios],meanResidenceTimes,meanTransitionRates}]*)
(*,{asymmetry,asymmetries}*)
(*,{timeFactor,timeFactors}];*)
(**)
(*(** overview plots **)*)
(*parameterString="_rDroplet_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]*)
(*<>"_diffS_"<>ToString[DecimalForm[diffS,{5,1}]]*)
(*<>"_rEcoli_0.5.";*)
(*plotWidth=ListDensityPlot[Flatten[simData[[All,All,{1,2,3}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"time factor","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"];*)
(*Export[FileNameJoin[{pthout,"overview_width"<>parameterString<>#}],plotWidth]&/@{"png"};*)
(*plotRatios=ListDensityPlot[Flatten[simData[[All,All,{1,2,4}]],1],FrameStyle->Directive[Black,18],InterpolationOrder->0,PlotRange->All,FrameLabel->{"time factor","asymmetry"},PlotLegends->True,ImageSize->500,PlotRangePadding->None,ColorFunction->"BlueGreenYellow"];*)
(*Export[FileNameJoin[{pthout,"overview_ratios"<>parameterString<>#}],plotRatios]&/@{"png"};*)
(*Print[Grid[{{plotWidth,plotRatios}}]];*)
(**)
(*(** save data **)*)
(*Export[FileNameJoin[{pthout,"simAnalysisData"<>parameterString<>".hdf5"}],simData];*)
(**)
(*,{rDropletDim,rDropletDims}]; *)
(*][[1]]];*)


(* ::Subsection::Closed:: *)
(*reanalyze data*)


(* ::Subsubsection::Closed:: *)
(*get spectra data*)


(* ::Input:: *)
(*parameterString="_rDroplet_5_3.50_rEcoli_0.5";*)
(*pthout=FileNameJoin[{NotebookDirectory[],(*"output_telegraph"*)"output_individual_spectra_i"}];*)
(*spectraTheta=Import[FileNameJoin[{pthout,"spectraTheta"<>parameterString<>".h5"}],"Dataset1"];*)
(*spectraI=Import[FileNameJoin[{pthout,"spectraIntensity"<>parameterString<>".h5"}],"Dataset1"];*)
(*simData=Import[FileNameJoin[{pthout,"simAnalysisData"<>parameterString<>".h5"}],"Dataset1"];*)


(* ::Subsubsection::Closed:: *)
(*width / mean angle*)


(* ::Input:: *)
(*plotOps={AspectRatio->1,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],ImageSize->500,*)
(*PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ColorFunction->"BlueGreenYellow",Mesh->All(*,ScalingFunctions\[Rule]{"Reverse",Identity}*)};*)
(*u0DimData=10^6 GeneralUtilities`AssociationTranspose[simData]["u0Dim"];*)
(*meanThetaData=GeneralUtilities`AssociationTranspose[simData]["meanTheta"];*)
(*iWidthData=GeneralUtilities`AssociationTranspose[simData]["iWidth"];*)
(**)
(*u0Dims=(Range[1,20,1] 1.0*^-6);*)
(*u0Max=Max[u0Dims] 1.0*^6;*)
(*plotSpeedMeanTheta=ListLinePlot[{{u0DimData,meanThetaData}\[Transpose]},ColorFunction->Automatic,(*ScalingFunctions\[Rule]{"Reverse","Reverse"},*)Evaluate[plotOps],PlotRange->{{1,u0Max},{0,\[Pi]}},FrameLabel->{"speed \!\(\**)
(*StyleBox[SubscriptBox[\"u\", \"0\"],\nFontSlant->\"Italic\"]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","mean angle \!\(\**)
(*StyleBox[\"\[LeftAngleBracket]\",\nFontSlant->\"Italic\"]\)\!\(\**)
(*StyleBox[\"\[Theta]\",\nFontSlant->\"Italic\"]\)\!\(\**)
(*StyleBox[\"\[RightAngleBracket]\",\nFontSlant->\"Italic\"]\) (rad)"}]*)
(*Export[FileNameJoin[{pthout,"plotSpeedMeanTheta.png"}],plotSpeedMeanTheta];*)
(*plotSpeedWidth=ListLinePlot[{{u0DimData,iWidthData}\[Transpose]},ColorFunction->Automatic,Evaluate[plotOps],PlotRange->{{1,u0Max},{0,All}},FrameLabel->{"speed \!\(\**)
(*StyleBox[SubscriptBox[\"u\", \"0\"],\nFontSlant->\"Italic\"]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","width (Hz)"}]*)
(*Export[FileNameJoin[{pthout,"plotSpeedWidth.png"}],plotSpeedWidth];*)
(*plotMeanThetaWidth=ListLinePlot[{{meanThetaData,iWidthData}\[Transpose]},ColorFunction->Automatic,ScalingFunctions->{Identity,Identity},Evaluate[plotOps],PlotRange->{{0,\[Pi]/2},{0,All}},FrameLabel->{"mean angle \[LeftAngleBracket]\[Theta]\[RightAngleBracket] (rad)","width (Hz)"}]*)
(*Export[FileNameJoin[{pthout,"plotMeanThetaWidth.png"}],plotMeanThetaWidth];*)


(* ::Subsubsection::Closed:: *)
(*plot spectra*)


(* ::Input:: *)
(*ListLinePlot[spectraTheta[[All,;;200;;1]],PlotRange->All,Mesh->All,Frame->True,AspectRatio->1]*)
(*ListLinePlot[spectraI[[All,;;200;;1]],PlotRange->All,Mesh->All,Frame->True,AspectRatio->1]*)


(* ::Input:: *)
(*ListPlot[{freqs,#}\[Transpose]&/@spectraTheta,AspectRatio->1,PlotRange->{{0,0.3},All},PlotStyle->(ColorData["BlueGreenYellow"][#]&/@Subdivide[Length[spectraTheta]-1]),Frame->True,FrameLabel->{"frequency f (Hz)","PSD(\[Theta])"},Joined->True,FrameStyle->Directive[Black,20]]*)


(* ::Input:: *)
(*maxFreqs=freqs[[Ordering[#][[-1]]&/@spectraTheta]]*)


(* ::Subsubsection::Closed:: *)
(*explore agreement of mean frequency and peak in Subscript[PSD, \[Theta]]*)


(* ::Input:: *)
(*{rDropletDim,rEcoliDim}={3.5,0.5} 1*^-6;*)
(*ListLinePlot[simData[[1;;,10]]/(2\[Pi] (rDropletDim+rEcoliDim)),PlotStyle->ColorData[97,3],Mesh->All,PlotLegends->{"\[LeftAngleBracket]v\[RightAngleBracket] / 2\[Pi] r"}]*)


(* ::Input:: *)
(*rEcoliDim=0.5*^-6;*)
(*peakError=Differences[freqs][[1]];*)
(*Show[*)
(*ListLinePlot[freqs[[Ordering[#][[-1]]&/@spectraTheta]],Frame->True,AspectRatio->1,FrameLabel->{"speed \!\(\*SubscriptBox[\(u\), \(0\)]\)","peak frequency \!\(\*SubscriptBox[\(f\), \(max\)]\) (Hz)"},Mesh->All,PlotLegends->{"Peak Position"}],*)
(*ListLinePlot[peakPositions,Frame->True,AspectRatio->1,FrameLabel->{"speed \!\(\*SubscriptBox[\(u\), \(0\)]\)","peak frequency \!\(\*SubscriptBox[\(f\), \(max\)]\) (Hz)"},Mesh->All,PlotStyle->ColorData[97,2],PlotLegends->{"Lorentzian fit Peak Position"}],*)
(*ListLinePlot[simData[[1;;,ks[[1]]]](*1*^-6Range[20]*)/(2\[Pi] (rDropletDim+rEcoliDim)),PlotStyle->ColorData[97,3],Mesh->All,PlotLegends->{"\[LeftAngleBracket]v\[RightAngleBracket] / 2\[Pi] r"}]*)
(*,PlotRange->All,FrameStyle->Directive[Black,20]*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*plot parameter planes of run/tumble times*)


(* ::Input:: *)
(*{dayIndex1,dayIndex6}={10,1};*)
(*widthContour1=0.15;*)
(*thetaContour1=12;*)
(*widthContour6=0.1;*)
(*thetaContour6=2.0;*)
(*ops={FrameStyle->Directive[Black,18],FrameLabel->{"\!\(\*SubscriptBox[\(t\), \(R\)]\)","\!\(\*SubscriptBox[\(t\), \(T\)]\)"}};*)
(*p1=ListContourPlot[cubeWidthData[[dayIndex1]],PlotLegends->Automatic,InterpolationOrder->1,ScalingFunctions->{"Log10","Log10"},PlotRangePadding->None,PlotLabel->"speed: 10 micron/s",ImageSize->{Automatic,400},Contours->{widthContour1},Evaluate[ops]];*)
(*p2=ListContourPlot[cubeWidthData[[dayIndex6]],PlotLegends->Automatic,InterpolationOrder->1,ScalingFunctions->{"Log10","Log10"},PlotRangePadding->None,PlotLabel->"speed: 1 micron/s",ImageSize->{Automatic,400},Contours->{widthContour6},Evaluate[ops]];*)
(*p3=ListContourPlot[cubeAngleData[[dayIndex1]],PlotLegends->Automatic,InterpolationOrder->1,ScalingFunctions->{"Log10","Log10"},PlotRangePadding->None,PlotLabel->"speed: 10 micron/s",ImageSize->{Automatic,400},Contours->{thetaContour1},Evaluate[ops]];*)
(*p4=ListContourPlot[cubeAngleData[[dayIndex6]],PlotLegends->Automatic,InterpolationOrder->1,ScalingFunctions->{"Log10","Log10"},PlotRangePadding->None,PlotLabel->"speed: 1 micron/s",ImageSize->{Automatic,400},Contours->{thetaContour6},Evaluate[ops]];*)
(*plot=Grid[{{"","width (Hz)","mean theta (\[Degree])"},{"day 1",p1,p3},{"day 6",p2,p4}}]*)
(*Export[FileNameJoin[{NotebookDirectory[],"widthThetaIntersections.png"}],plot]*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*parameterStrings="simAnalysisData_rDroplet_3.50_u0Dim_"<>ToString[DecimalForm[N@#,{3,2}]]<>".h5"&/@Range[1,12];*)
(*plotOps={AspectRatio->1,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],ImageSize->{Automatic,500},*)
(*PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ColorFunction->"BlueGreenYellow",Mesh->All,ScalingFunctions->{"Reverse",Identity}};*)
(*{widthMin,widthMax}={0.0,0.35};*)
(*{thetaMin,thetaMax}={0.0,45};*)
(*(*pthout="C:\\Users\\Jan\\Dropbox (MIT)\\Bacteria Droplet Manuscript\\Code\\Mathematica\\output\\output_runTumbleRateScan_iThetaPhi_10x10x3";*)*)
(*pthout="/home/jan/Dropbox (MIT)/Bacteria Droplet Manuscript/Code/Mathematica/output/output_fig3_4_fine_scan2";*)
(*{cubeWidthData,cubeAngleData,plotsWidth,plotsMeanTheta}=Table[*)
(*simData=Import[FileNameJoin[{pthout,parameterString}],"/Dataset1"];*)
(*runtimeData=GeneralUtilities`AssociationTranspose[simData]["tRun"];*)
(*tumbletimeData=GeneralUtilities`AssociationTranspose[simData]["tTumble"];*)
(*iWidthData=GeneralUtilities`AssociationTranspose[simData]["iWidth"];*)
(*meanThetaData=GeneralUtilities`AssociationTranspose[simData]["meanTheta"];*)
(*speedString=StringSplit[FileBaseName[parameterString],"_"][[-1]];*)
(*plotWidth=Column[{speedString,Row[{*)
(*ListDensityPlot[{runtimeData,tumbletimeData,iWidthData}\[Transpose],ImageSize->{Automatic,400},PlotRange->All,InterpolationOrder->0,FrameLabel->{"run time \!\(\**)
(*StyleBox[SubscriptBox[\"t\", \"R\"],\nFontSlant->\"Italic\"]\) (s)","tumble time \!\(\**)
(*StyleBox[SubscriptBox[\"t\", \"T\"],\nFontSlant->\"Italic\"]\) (s)"},PlotRangePadding->None,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],ScalingFunctions->{"Log10","Log10"},ColorFunctionScaling->False,ColorFunction->(GrayLevel[Rescale[#,{widthMin,widthMax}]]&),ImagePadding->{{75,10},{60,10}}],*)
(*Show[colorbar[{0,1},{Subdivide[0.0,1,8-1],DecimalForm[#,{3,2}]&/@Subdivide[0,0.35,8-1]}\[Transpose],False,20,400,"width \!\(\*SubscriptBox[\(PSD\), \(I\)]\) (Hz)",2,GrayLevel,True],ImagePadding->{{1,80},{60,10}}]*)
(*}]}];*)
(*plotMeanTheta=Column[{speedString,Row[{*)
(*ListDensityPlot[{runtimeData,tumbletimeData,180/\[Pi] meanThetaData}\[Transpose],ImageSize->{Automatic,400},PlotRange->All,InterpolationOrder->0,FrameLabel->{"run time \!\(\**)
(*StyleBox[SubscriptBox[\"t\", \"R\"],\nFontSlant->\"Italic\"]\) (s)","tumble time \!\(\**)
(*StyleBox[SubscriptBox[\"t\", \"T\"],\nFontSlant->\"Italic\"]\) (s)"},PlotRangePadding->None,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],ScalingFunctions->{"Log10","Log10"},ColorFunctionScaling->False,ColorFunction->(GrayLevel[Rescale[#,{thetaMin,thetaMax}]]&),ImagePadding->{{75,10},{60,10}}],*)
(*Show[colorbar[{0,1},{Subdivide[0.0,1,4-1],Round@Subdivide[0,thetaMax,4-1]}\[Transpose],False,20,400,"mean polar angle \!\(\**)
(*StyleBox[\"\[LeftAngleBracket]\",\nFontSlant->\"Italic\"]\)\!\(\**)
(*StyleBox[\"\[Theta]\",\nFontSlant->\"Italic\"]\)\!\(\**)
(*StyleBox[\"\[RightAngleBracket]\",\nFontSlant->\"Italic\"]\) (\[Degree])",2,GrayLevel,True],ImagePadding->{{1,80},{60,10}}]*)
(*}]}];*)
(*{{runtimeData,tumbletimeData,iWidthData}\[Transpose],{runtimeData,tumbletimeData,180/\[Pi] meanThetaData}\[Transpose],plotWidth,plotMeanTheta}*)
(*,{parameterString,parameterStrings}]\[Transpose];*)
(*plotsWidth*)
(*plotsMeanTheta*)
(*Grid[{#&/@plotsWidth}]*)
(*Grid[{#&/@plotsMeanTheta}]*)


(* ::Subsection::Closed:: *)
(*plot forces and velocity over age*)


(* ::Input:: *)
(*trajectory=trajectories[[-1]];*)


(* ::Input:: *)
(*xyz=trajectory[[All,{1,2,3}]];    (** position **)*)
(*pxyz=trajectory[[All,{4,5,6}]];   (** polarization **)*)
(*s=trajectory[[All,7]];            (** RT state variable **)*)
(*projectionMatrices=sphereSurfaceProjector[#,{0,0,0}]&/@xyz[[;;-2]];*)
(*velocity=Differences[xyz]/dt;(*MapThread[#1.#2&,{projectionMatrices,Differences[xyz]/dt}];*)*)
(*swimForce=swimFactor MapThread[(1.0-#1) #2&,{s[[;;-2]],pxyz[[;;-2]]}];  (** polarization vector is already tangent to sphere **)*)
(*gravForce=(# . {0,0,1} gravFactor)&/@projectionMatrices;*)


(* ::Input:: *)
(*ops={AspectRatio->1,Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],PlotRange->{{0,60},All},ImageSize->500};*)
(*\[Theta]plot=ListLinePlot[{times,thetaData}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","polar angle \[Theta]"}];*)
(*\[Phi]plot=ListLinePlot[{times,phiData}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","azimuthal angle \[Phi]"}];*)
(*vplot=ListLinePlot[{times[[;;-2]],10^6rDropletDim Norm/@velocity}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","velocity |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)"}];*)
(*vzplot=ListLinePlot[{times[[;;-2]],10^6rDropletDim velocity[[All,3]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","velocity \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)"}];*)
(*fplot=ListLinePlot[{{times[[;;-2]],10^12rDropletDim Norm/@swimForce}\[Transpose],{times[[;;-2]],10^12rDropletDim Norm/@gravForce}\[Transpose]},Evaluate[ops],FrameLabel->{"time t (s)","force |F| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)"},PlotLegends->{"swim","grav"}];*)
(*pplot=ListLinePlot[{times[[;;]],Norm/@pxyz}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","|p|"},Axes->False];*)
(*fzplot=ListLinePlot[{{times[[;;-2]],10^12rDropletDim swimForce[[All,3]]}\[Transpose],{times[[;;-2]],10^12rDropletDim gravForce[[All,3]]}\[Transpose]},Evaluate[ops],FrameLabel->{"time t (s)","force \!\(\*SubscriptBox[\(F\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)"},PlotLegends->{"swim","grav"},Axes->False];*)
(*Grid[{{\[Phi]plot,vplot,fplot},{\[Theta]plot,vzplot,fzplot}}]*)


(* ::Subsubsection::Closed:: *)
(*import data*)


(* ::Input:: *)
(*rDropletDim=3.5*1*^-6;*)
(*parameterString="_rDroplet_3_"<>ToString[DecimalForm[rDropletDim 1*^6,{3,2}]]<>"_rEcoli_0.5";*)
(*pthout=FileNameJoin[{NotebookDirectory[],"output"}];*)
(*simData=Import[FileNameJoin[{pthout,"simAnalysisData"<>parameterString<>".h5"}],"Dataset1"];*)


(* ::Input:: *)
(*plotWidth=ListLinePlot[{10^6#[[1]],#[[2]]}&/@simData[[All,{1,3}]],AspectRatio->1,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{1,20},{0,All}},FrameLabel->{"speed \!\(\*SubscriptBox[\(u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","width w (Hz)"},PlotLegends->True,ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ColorFunction->"BlueGreenYellow",Mesh->All,ScalingFunctions->{"Reverse",Identity}]*)
(*Export[FileNameJoin[{pthout,"overview_width"<>parameterString<>"."<>#}],plotWidth]&/@{"png"};*)


(* ::Input:: *)
(*ks=Range[10,45,2];*)
(*factors={10^6,10^6,10^6,10^12,10^12,10^12,10^6,10^6,10^6,10^12,10^12,10^12,10^12,10^12,10^12,10^12,10^12,10^12};*)
(*simDataHeaders={"\!\(\*SubscriptBox[\(u\), \(0\)]\) (m/s)","\!\(\*SubscriptBox[\(width\), \(\[Theta]\)]\)(f) (Hz)","\!\(\*SubscriptBox[\(width\), \(I\)]\)(f) (Hz)","\[LeftAngleBracket]RT ratio\[RightAngleBracket]","std RT ratio","\[LeftAngleBracket]residence time R\[RightAngleBracket]","\[LeftAngleBracket]residence time T\[RightAngleBracket]","\[LeftAngleBracket]transition rate R\[RightAngleBracket]","\[LeftAngleBracket]transition rate T\[RightAngleBracket]",*)
(*"mean |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","std |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)", (** 10 **)*)
(*"mean min |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","std min |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",*)
(*"mean max |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","std max |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",*)
(**)
(*"mean |\!\(\*SubscriptBox[\(F\), \(swim\)]\)| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std |\!\(\*SubscriptBox[\(F\), \(swim\)]\)| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean |\!\(\*SubscriptBox[\(F\), \(g\)]\)| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std |\!\(\*SubscriptBox[\(F\), \(g\)]\)| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean |\!\(\*SubscriptBox[\(F\), \(swim\)]\)+\!\(\*SubscriptBox[\(F\), \(g\)]\)| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std |\!\(\*SubscriptBox[\(F\), \(swim\)]\)+\!\(\*SubscriptBox[\(F\), \(g\)]\)| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(**)
(*"mean \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","std \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",*)
(*"mean min \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","std min \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",*)
(*"mean max \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","std max \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",*)
(**)
(*"mean \!\(\*SubscriptBox[\(F\), \(swim, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std \!\(\*SubscriptBox[\(F\), \(swim, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean min \!\(\*SubscriptBox[\(F\), \(swim, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std min \!\(\*SubscriptBox[\(F\), \(swim, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean max \!\(\*SubscriptBox[\(F\), \(swim, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std max \!\(\*SubscriptBox[\(F\), \(swim, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(**)
(*"mean \!\(\*SubscriptBox[\(F\), \(g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std \!\(\*SubscriptBox[\(F\), \(g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean min \!\(\*SubscriptBox[\(F\), \(g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std min \!\(\*SubscriptBox[\(F\), \(g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean max \!\(\*SubscriptBox[\(F\), \(g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std max \!\(\*SubscriptBox[\(F\), \(g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(**)
(*"mean \!\(\*SubscriptBox[\(F\), \(swim + g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std \!\(\*SubscriptBox[\(F\), \(swim + g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean min \!\(\*SubscriptBox[\(F\), \(swim + g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std min \!\(\*SubscriptBox[\(F\), \(swim + g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)",*)
(*"mean max \!\(\*SubscriptBox[\(F\), \(swim + g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)","std max \!\(\*SubscriptBox[\(F\), \(swim + g, z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)"*)
(*};*)


(* ::Input:: *)
(*(** plot of |forces| **)*)
(*ii=4;*)
(*cols=ColorData[97,#]&/@Range[3];*)
(*headers={"\!\(\*SubscriptBox[\(F\), \(swim\)]\)","\!\(\*SubscriptBox[\(F\), \(g\)]\)","\!\(\*SubscriptBox[\(F\), \(swim\)]\)+\!\(\*SubscriptBox[\(F\), \(g\)]\)"};*)
(*colCounter=1;*)
(*plot=Show[*)
(*Table[*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*(** plot of mean with standard deviation **)*)
(*Show[*)
(*col=cols[[colCounter]];*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[10;;,{1,k}]]]\[Transpose],PlotStyle->Directive[col,AbsoluteThickness[4]],PlotLegends->{headers[[colCounter++]](*simDataHeaders\[LeftDoubleBracket]ks\[LeftDoubleBracket]i\[RightDoubleBracket]\[RightDoubleBracket]*)}],*)
(*ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[10;;,{1,k}]],simData[[10;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->col]*)
(*]*)
(*,{i,ii,ii+2}]*)
(*,AspectRatio->1,Axes->None,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{0,10},{0,All}},FrameLabel->{"speed difference \!\(\*SubscriptBox[\(\[CapitalDelta]u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","mean force |F| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)"},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}}*)
(*]*)
(*Export[FileNameJoin[{pthout,"abs_forces_plot.png"}],plot];*)


(* ::Input:: *)
(*(** plot of |velocity| and |forces| **)*)
(*ii=4;*)
(*cols=ColorData[97,#]&/@Range[3];*)
(*headers={"\!\(\*SubscriptBox[\(F\), \(swim\)]\)","\!\(\*SubscriptBox[\(F\), \(g\)]\)","\!\(\*SubscriptBox[\(F\), \(swim\)]\)+\!\(\*SubscriptBox[\(F\), \(g\)]\)"};*)
(*colCounter=1;*)
(*ip={{100,90},{80,20}};*)
(*plot=Overlay[{*)
(*(** left y-scale **)*)
(*Show[*)
(*Table[*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*(** plot of mean with standard deviation **)*)
(*Show[*)
(*col=cols[[colCounter]];*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[10;;,{1,k}]]]\[Transpose],PlotStyle->Directive[col,AbsoluteThickness[4]],PlotLegends->{headers[[colCounter++]](*simDataHeaders\[LeftDoubleBracket]ks\[LeftDoubleBracket]i\[RightDoubleBracket]\[RightDoubleBracket]*)}],*)
(*ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[10;;,{1,k}]],simData[[10;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->col]*)
(*]*)
(*,{i,ii,ii+2}]*)
(*,AspectRatio->1,Axes->None,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{0,10},{0,All}},FrameLabel->{"speed difference \!\(\*SubscriptBox[\(\[CapitalDelta]u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","mean force |F| (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)"},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ImagePadding->ip,FrameTicks->{{True,False},{True,True}}*)
(*]*)
(*,*)
(*(** right y-scale **)*)
(*i=1;*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*(** plot of mean with standard deviation **)*)
(*Show[*)
(*col=Gray;*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[10;;,{1,k}]]]\[Transpose],PlotStyle->Directive[col,Dashed,AbsoluteThickness[4]]]*)
(*,ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[10;;,{1,k}]],simData[[10;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->Directive[col,Dashed]]*)
(*,AspectRatio->1,Axes->None,Frame->{{False,True},{False,False}},FrameStyle->Directive[col,28,AbsoluteThickness[2]],PlotRange->{{0,10},{0,All}},FrameLabel->{{"","mean velocity |v| (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)"},{"",""}},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ImagePadding->ip,FrameTicks->{{False,All},{False,False}}*)
(*]*)
(*}]*)
(*Export[FileNameJoin[{pthout,"abs_forces_velocity_plot.png"}],plot];*)


(* ::Input:: *)
(*(** plot of Subscript[velocity, z] and Subscript[forces, z] **)*)
(*ii=10;*)
(*cols=ColorData[97,#]&/@Range[3];*)
(*headers={"\!\(\*SubscriptBox[\(F\), \(swim\)]\)","\!\(\*SubscriptBox[\(F\), \(g\)]\)","\!\(\*SubscriptBox[\(F\), \(swim\)]\)+\!\(\*SubscriptBox[\(F\), \(g\)]\)"};*)
(*colCounter=1;*)
(*ip={{120,120},{80,20}};*)
(*plot=Overlay[{*)
(*(** left y-scale **)*)
(*Show[*)
(*Table[*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*(** plot of mean with standard deviation **)*)
(*Show[*)
(*col=cols[[colCounter]];*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[5;;,{1,k}]]]\[Transpose],PlotStyle->Directive[col,AbsoluteThickness[4]],PlotLegends->{headers[[colCounter++]](*simDataHeaders\[LeftDoubleBracket]ks\[LeftDoubleBracket]i\[RightDoubleBracket]\[RightDoubleBracket]*)}],*)
(*ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[5;;,{1,k}]],simData[[5;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->col]*)
(*]*)
(*,{i,{10,13,16}}]*)
(*,AspectRatio->1,Axes->None,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{0,15},0.12{-1,1}},FrameLabel->{"speed difference \!\(\*SubscriptBox[\(\[CapitalDelta]u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","mean force \!\(\*SubscriptBox[\(F\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-12\)]\) N)"},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ImagePadding->ip,FrameTicks->{{True,False},{True,True}}*)
(*]*)
(*,*)
(*(** right y-scale **)*)
(*i=7;*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*(** plot of mean with standard deviation **)*)
(*Show[*)
(*col=Gray;*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[5;;,{1,k}]]]\[Transpose],PlotStyle->Directive[col,AbsoluteThickness[4]]],*)
(*ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[5;;,{1,k}]],simData[[5;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->col]*)
(*,AspectRatio->1,Axes->None,Frame->{{False,True},{False,False}},FrameStyle->Directive[col,28,AbsoluteThickness[2]],PlotRange->{{0,15},0.03{-1,1}},FrameLabel->{{"","mean velocity \!\(\*SubscriptBox[\(v\), \(z\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)"},{"",""}},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ImagePadding->ip,FrameTicks->{{False,All},{False,False}}*)
(*]*)
(*}]*)
(*Export[FileNameJoin[{pthout,"z_forces_velocity_plot.png"}],plot]*)


(* ::Input:: *)
(*(** all data **)*)
(*Do[*)
(*plot=Show[*)
(*Evaluate@Table[*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*(** plot of mean with standard deviation **)*)
(*Show[*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[10;;,{1,k}]]]\[Transpose],PlotStyle->Directive[ColorData[97,1],AbsoluteThickness[4]]],*)
(*ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[10;;,{1,k}]],simData[[10;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->ColorData[97,1]]*)
(*,AspectRatio->1,Axes->None,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{0,10},All},FrameLabel->{"speed difference \!\(\*SubscriptBox[\(\[CapitalDelta]u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",simDataHeaders[[k]]},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},PlotStyle->ColorData[97,1](*ColorFunction\[Rule]"BlueGreenYellow",*)*)
(*]*)
(*,{i,ii,ii+2}]*)
(*];*)
(*Print[plot];*)
(*,{ii,1,Length[ks]-2,3}];*)


(* ::Input:: *)
(*Do[*)
(*k=ks[[i]];*)
(*factor=factors[[i]];*)
(*plot=Show[*)
(*ListLinePlot[Sort@Map[{{20-10^6#[[1]],factor #[[2]]}}&,simData[[10;;,{1,k}]]]\[Transpose],PlotStyle->Directive[ColorData[97,1],AbsoluteThickness[4]]],*)
(*ListLinePlot[Evaluate[Sort/@Transpose[MapThread[{{20-10^6#1[[1]],factor(#1[[2]]+#2[[2]])},{20-10^6#1[[1]],factor(#1[[2]]-#2[[2]])}}&,{simData[[10;;,{1,k}]],simData[[10;;,{1,k+1}]]}]]],Filling->{1->{2}},PlotStyle->ColorData[97,1]]*)
(*,AspectRatio->1,Axes->None,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{0,10},All},FrameLabel->{"speed difference \!\(\*SubscriptBox[\(\[CapitalDelta]u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)",simDataHeaders[[k]]},ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},PlotStyle->ColorData[97,1](*ColorFunction\[Rule]"BlueGreenYellow",*)*)
(*];*)
(*(*Print[plot];*)*)
(*Export[FileNameJoin[{NotebookDirectory[],"velocity_force_"<>ToString[k]<>"_"<>parameterString<>"."<>#}],plot]&/@{"png"(*,"pdf"*)};*)
(*,{i,Length[ks]}];*)


(* ::Input:: *)
(*plotWidthPaper=ListLinePlot[{20-10^6#[[1]],#[[2]]}&/@simData[[10;;,{1,3}]],AspectRatio->1,Frame->True,FrameStyle->Directive[Black,28,AbsoluteThickness[2]],PlotRange->{{0,10},{0,All}},FrameLabel->{"speed difference \!\(\*SubscriptBox[\(\[CapitalDelta]u\), \(0\)]\) (\!\(\*SuperscriptBox[\(10\), \(-6\)]\) m/s)","width w (Hz)"},PlotLegends->True,ImageSize->500,PlotRangePadding->{Scaled[0.02],{0,Scaled@0.05}},ColorFunction->"BlueGreenYellow",Mesh->All]*)
(*Export[FileNameJoin[{NotebookDirectory[],"overview_width"<>parameterString<>"."<>#}],plotWidthPaper]&/@{"png","pdf"};*)


(* ::Subsection::Closed:: *)
(*checks*)


(* ::Input:: *)
(*projTests=Table[#[[1;;3]] . #[[4;;6]]&/@trajectory,{trajectory,trajectories}];*)
(*ListLinePlot[projTests,PlotRange->All,Frame->True,PlotRange->All]*)


(* ::Input:: *)
(*rtStates=Map[If[#<0.5,0,1]&,trajectories[[All,All,7]],{2}];*)
(*rtRatios=N[Count[#,1]/nSteps]&/@rtStates;*)
(*meanStd[rtRatios]*)
(*residenceDatas=Table[Sort[{First[#],Length[#]}&/@Split[rtState]],{rtState,rtStates}];*)


(* ::Subsection::Closed:: *)
(*single trajectory visualization*)


(* ::Input:: *)
(*tumbleColor=RGBColor[1, 0.7000000000000001, 0];(*Red*)(*Orange*)*)
(*times=Range[0,tfinalSim,dt];*)
(**)
(*Manipulate[*)
(*rtState=If[#<0.5,0,1]&/@trajectories[[t,All,7]];*)
(*sData=trajectories[[t,All,7]];*)
(*thetaData=ArcCos[#[[3]]]&/@trajectories[[t,All,{1,2,3}]];*)
(*phiData=phaseUnwrap[ArcTan[#[[1]],#[[2]]]&/@trajectories[[t,All,{1,2}]]];*)
(*iData=Cos[#]^2&/@thetaData;*)
(*psds=calculateTemporalFreqSpectrum[dt,sData][[{1,2}]]\[Transpose];*)
(*psd\[Theta]=calculateTemporalFreqSpectrum[dt,thetaData][[{1,2}]]\[Transpose];*)
(*psdi=calculateTemporalFreqSpectrum[dt,iData][[{1,2}]]\[Transpose];*)
(*fit=NonlinearModelFit[psdi,amp/( 1+x^2/b^2),{{amp,1},{b,0.1}},x];*)
(*(** plots **)*)
(*ops={AspectRatio->1,ImageSize->400,Frame->True,FrameStyle->Directive[Black,20,AbsoluteThickness[2]],ColorFunctionScaling->False,ColorFunction->Function[{t,y},If[rtState[[Round[t/dt]]]==0,Darker@Gray,(*Darker@Gray*)tumbleColor]]};*)
(*tmax=Round[0.6Length[iData]];*)
(*p1=ListLinePlot[{times,trajectories[[t,All,1]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","x"}];*)
(*p2=ListLinePlot[{times,trajectories[[t,All,2]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","y"}];*)
(*p3=ListLinePlot[{times,trajectories[[t,All,3]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","z"}];*)
(*p4=ListLinePlot[{times,trajectories[[t,All,4]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","\!\(\*SubscriptBox[\(p\), \(x\)]\)"}];*)
(*p5=ListLinePlot[{times,trajectories[[t,All,5]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","\!\(\*SubscriptBox[\(p\), \(y\)]\)"}];*)
(*p6=ListLinePlot[{times,trajectories[[t,All,6]]}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","\!\(\*SubscriptBox[\(p\), \(z\)]\)"}];*)
(*p\[Theta]=ListLinePlot[{times,thetaData}\[Transpose][[;;tmax]],Evaluate[ops],FrameLabel->{"time t (s)","\[Theta]"},Prolog->{Gray,Line[{{0,0.5\[Pi]},{tfinalSim,0.5\[Pi]}}]},PlotRange->{0,\[Pi]},ScalingFunctions->{None,"Reverse"}];*)
(*p\[Phi]=ListLinePlot[{times,phiData}\[Transpose],Evaluate[ops],FrameLabel->{"time t (s)","\[Phi]"}];*)
(*ps=ListLinePlot[{times,sData}\[Transpose][[;;tmax]],Evaluate[ops],FrameLabel->{"time t (s)","state s"}];*)
(*pi=ListLinePlot[{times,iData}\[Transpose][[;;tmax]],Evaluate[ops],FrameLabel->{"time t (s)","\!\(\*SuperscriptBox[\(cos\), \(2\)]\)\[Theta]"},PlotRange->{{0,60},{0,1}}];*)
(*pPSDs=ListLinePlot[psds[[;;300]],Evaluate[ops],FrameLabel->{"frequency f (Hz)","PSD(s)"},PlotRange->{0,1}];*)
(*pPSD\[Theta]=ListLinePlot[psd\[Theta][[;;300]],Evaluate[ops],FrameLabel->{"frequency f (Hz)","PSD(\[Theta])"},PlotRange->All];*)
(*pPSDi=Show[*)
(*ListLinePlot[{#[[1]],#[[2]]/Max[psdi[[All,2]]]}&/@psdi,Evaluate[ops],FrameLabel->{"frequency f (Hz)","PSD(i)"},PlotRange->{{0,1},All}],*)
(*Plot[fit[x],{x,0,1},PlotStyle->Red,PlotRange->All]*)
(*];*)
(*plot=Grid[{{ps,pPSDs},{p\[Theta],pPSD\[Theta]},{pi,pPSDi}}]*)
(*,{t,1,Length[trajectories],1,Appearance->"Open"},TrackedSymbols:>{t}]*)


(* ::Input:: *)
(*trajectory=trajectories[[-1]];*)
(*indexlist=Rescale[Range@Length@trajectory];*)
(*plotSphere=Graphics3D[{Opacity[0.1],Sphere[]}];*)
(*rEcoli=(*0.03*)0.5/(rDropletDim 10^6);*)
(*Manipulate[*)
(*{x,y,z,px,py,pz}=trajectory[[t,1;;6]];*)
(*position={x,y,z};*)
(*orientation={px,py,pz};*)
(*{front,end}=Transpose[(1+rEcoli)position+0.5Transpose[2rEcoli{#,-#}&@orientation]];*)
(*plotStochastic=Show[plotSphere,*)
(*Graphics3D[{ColorData[97,1],AbsoluteThickness[3],Line[#&/@trajectory[[;;t,{1,2,3}]],VertexColors->(If[#==0,Darker@Gray,Red]&/@rtState)(*(ColorData["Rainbow"]/@indexlist)*)]}],*)
(*Graphics3D[{If[rtState[[t]]==0,Darker@Gray,Red],CapsuleShape[{front,end},rEcoli]}],*)
(*Graphics3D[{Black,Arrow[Tube[1.4{{0,0,-1},{0,0,1}}]]}]*)
(*,Boxed->False,Axes->False,ImageSize->500,PlotRange->{1.2{-1,1},1.2{-1,1},1.4{-1,1}}*)
(*];*)
(*plotDirector=Show[plotSphere,*)
(*Graphics3D[{ColorData[97,1],AbsoluteThickness[3],Line[trajectory[[;;t,{4,5,6}]],VertexColors->(If[#==0,Darker@Gray,Red]&/@rtState)(*(ColorData["Rainbow"]/@indexlist)*)]}],*)
(*Graphics3D[{*)
(*Black,Arrow[Tube[1.4{{0,0,-1},{0,0,1}}]],*)
(*If[rtState[[t]]==0,Darker@Gray,Red],Arrowheads[0.05],Arrow[Tube[{{0,0,0},(1+rEcoli)orientation}]]*)
(*}]*)
(*,Boxed->False,Axes->False,ImageSize->500,PlotRange->{1.1{-1,1},1.1{-1,1},1.4{-1,1}}*)
(*];*)
(*plot=Grid[{{Style["t = "<>ToString[t dt]<>"\[ThinSpace]s",Black,24,FontFamily->"Helvetica"],SpanFromLeft},Style[#,Black,24,FontFamily->"Helvetica"]&/@{"position","orientation vector"},{plotStochastic,plotDirector}}]*)
(*,{{t,1,"time step t"},1,Length[trajectory],1,Appearance->"Open"},TrackedSymbols:>{t}]*)


(* ::Input:: *)
(*tumbleColor=RGBColor[1, 0.7000000000000001, 0];(*Red*)(*Orange*)*)
(*indexlist=Rescale[Range@Length@trajectory];*)
(*plotSphere=Graphics3D[{Opacity[0.1],Sphere[]}];*)
(*rEcoli=(*0.03*)0.1;*)
(*Manipulate[*)
(*{x,y,z,px,py,pz}=trajectory[[t,1;;6]];*)
(*position={x,y,z};*)
(*orientation={px,py,pz};*)
(*{front,end}=Transpose[(1+rEcoli)position+0.5Transpose[4rEcoli{#,-#}&@orientation]];*)
(*plotDroplet=ParametricPlot3D[{RotationMatrix[{{0,0,1},position}] . er[\[Theta],\[Phi]],RotationMatrix[{{0,0,1},position}] . er[\[Pi]-\[Theta],\[Phi]]},{\[Theta],0,0.5\[Pi]},{\[Phi],0,2\[Pi]},Mesh->None,Axes->False,Boxed->False,PlotPoints->30,PlotStyle->{Directive[Opacity[0.9],Lighter@Red,Specularity[White,65]],Directive[Opacity[0.9],Lighter[Gray,0.7],Specularity[White,65]]},Lighting->(*Automatic*)"Neutral"];*)
(*plotStochastic=Show[plotDroplet,*)
(*Graphics3D[{ColorData[97,1],AbsoluteThickness[3],Line[#&/@trajectory[[;;t,{1,2,3}]],VertexColors->(If[#==0,Darker@Gray,tumbleColor]&/@rtState)(*(ColorData["Rainbow"]/@indexlist)*)]}],*)
(*Graphics3D[{If[rtState[[t]]==0,Darker@Gray,tumbleColor],CapsuleShape[{front,end},rEcoli]}],*)
(*Graphics3D[{Black,Arrow[Tube[1.4{{0,0,-1},{0,0,1}}]],Text[Style["z",20],{0,0.2,1 1.4}]}]*)
(*,Boxed->False,Axes->False,ImageSize->500,PlotRange->{1.1{-1,1},1.1{-1,1},1.4{-1,1}}*)
(*];*)
(*plotDirector=Show[plotSphere,*)
(*Graphics3D[{ColorData[97,1],AbsoluteThickness[3],Line[trajectory[[;;t,{4,5,6}]],VertexColors->(If[#==0,Darker@Gray,tumbleColor]&/@rtState)(*(ColorData["Rainbow"]/@indexlist)*)]}],*)
(*Graphics3D[{*)
(*Black,Arrow[Tube[1.4{{0,0,-1},{0,0,1}}]],Text[Style["z",20],{0,0.2,1 1.4}],*)
(*If[rtState[[t]]==0,Darker@Gray,tumbleColor],Arrowheads[0.05],Arrow[Tube[{{0,0,0},(1+rEcoli)orientation}]]*)
(*}]*)
(*,Boxed->False,Axes->False,ImageSize->500,PlotRange->{1.1{-1,1},1.1{-1,1},1.4{-1,1}}*)
(*];*)
(*labels=Style[#,Black,24,FontFamily->"Helvetica"]&/@{"position","orientation vector"};*)
(*plot=Grid[{labels,{plotStochastic(*,plotDirector*)}}]*)
(*,{{t,1,"time step t"},1,Length[trajectory],1,Appearance->"Open"},TrackedSymbols:>{t}]*)


(* ::Input:: *)
(*plotHemi=ParametricPlot3D[0.99er[\[Theta],\[Phi]],{\[Theta],0,\[Pi]/6},{\[Phi],0,2\[Pi]},Mesh->{3,10},MeshStyle->Directive[Black,AbsoluteThickness[1]],Axes->False,Boxed->False,PlotPoints->30*)
(*,PlotStyle->{*)
(*Directive[Opacity[0.9],Lighter[Gray,0.5],Specularity[White,50]]*)
(*},Lighting->"Neutral"]*)


(* ::Input:: *)
(*thetaData=ArcCos[#]&/@trajectories[[1,stepsTransient;;,3]];*)
(*180/\[Pi] thetaData//MinMax*)


(* ::Input:: *)
(*trajectories//Dimensions*)


(* ::Input:: *)
(*colors={RGBColor[0.63, 1, 0],RGBColor[0.5, 0.5, 0.5]};*)
(*color=colors[[1]];*)
(*{runColor,tumbleColor}={color,(*Darker@*)color};*)
(*trajectory=trajectories[[1]];*)
(*rtData=If[#<0.5,0,1]&/@trajectory[[stepsTransient;;,7]];*)
(*plot=Show[*)
(*plotHemi*)
(*(*Graphics3D[{(*Opacity[0.75],*)Sphere[],Opacity[1.0],(*Black*)Lighter[Black,0.4]*)
(*(*,Tube[#,0.005]&@circle3D[{0,0,0},1,{1,0,0}]*)
(*,Tube[#,0.005]&@circle3D[{0,0,0},1,{0,1,0}]*)*)
(*,Tube[#,0.005]&@circle3D[{0,0,0.8},0.6,{0,0,1}]*)
(*},Lighting->(*None*){"Neutral"}]*),*)
(*(*Graphics3D[{(*ColorData[97,1]*)Black,AbsoluteThickness[3],(*Tube@*)Line[{#\[LeftDoubleBracket]1\[RightDoubleBracket],#\[LeftDoubleBracket]2\[RightDoubleBracket],#\[LeftDoubleBracket]3\[RightDoubleBracket]0.99}&/@trajectory\[LeftDoubleBracket]stepsTransient;;(*tPlot*)-1(*3stepsTransient*),1;;3\[RightDoubleBracket](*,VertexColors\[Rule](If[#\[Equal]0,runColor,tumbleColor]&/@rtData)*)]}],*)*)
(*Graphics3D[{RGBColor[0.63, 1, 0],AbsoluteThickness[3],(*Tube@*)Line[#&/@trajectory[[stepsTransient;;(*tPlot*)-1(*3stepsTransient*);;100,1;;3]]]}],*)
(*	(*Graphics3D[{If[rtData\[LeftDoubleBracket]tPlot\[RightDoubleBracket]\[Equal]0,runColor,tumbleColor],CapsuleShape[{front,end},rEcoliShort]}],*)*)
(*Graphics3D[{Black,Arrow[Tube[1.15{{0,0,0},#}]]&/@{{1,0,0},{0,1,0},{0,0,1}}}]*)
(*,Boxed->False,Axes->False,ImageSize->500,PlotRange->{0.6{-1,1},0.6{-1,1},(*{-1,1}*){0.8,1.15}}*)
(*,ViewVertical->{0.25382230722830884`,0.2170238962392964`,0.9425894465855287`},ViewPoint->{2.371703754571365`,2.03021188081704`,1.3049053680406981`}*)
(*]*)
(*Export[FileNameJoin[{$HomeDirectory,"Desktop","plot.png"}],plot]*)


(* ::Input:: *)
(*colors={RGBColor[0.63, 1, 0],RGBColor[0.5, 0.5, 0.5]};*)
(*color=colors[[2]];*)
(*{runColor,tumbleColor}={color,(*Darker@*)color};*)
(*trajectory=trajectories[[1]];*)
(*rtData=If[#<0.5,0,1]&/@trajectory[[stepsTransient;;,7]];*)
(*Show[*)
(*Graphics3D[{Opacity[0.1],Sphere[],Opacity[1.0](*,Black,Tube[#,0.005]&@circle3D[{0,0,0},1,{1,0,0}],Tube[#,0.005]&@circle3D[{0,0,0},1,{0,1,0}],Tube[#,0.005]&@circle3D[{0,0,0},1,{0,0,1}]*)}],*)
(*Graphics3D[{ColorData[97,1],AbsoluteThickness[3],(*Tube@*)Line[#&/@trajectory[[stepsTransient;;(*tPlot*)(*-1*)2stepsTransient,1;;3]],VertexColors->(If[#==0,runColor,tumbleColor]&/@rtData)]}],	(*Graphics3D[{If[rtData\[LeftDoubleBracket]tPlot\[RightDoubleBracket]\[Equal]0,runColor,tumbleColor],CapsuleShape[{front,end},rEcoliShort]}],*)*)
(*Graphics3D[{Black,Arrow[Tube[1.3{{0,0,0},#}]]&/@{{1,0,0},{0,1,0},{0,0,1}}}]*)
(*,Boxed->False,Axes->False,ImageSize->500,PlotRange->1.4{{-1,1},{-1,1},{-1,1}}*)
(*,ViewVertical->{0.376,0.248,0.893},ViewPoint->{2.813,1.728,0.742}]*)
